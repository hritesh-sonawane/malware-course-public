---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::



---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 21: Packers, Remote Loading, Intro to PI 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Last Time

:::

<!-- element style="font-size: 24px"-->
- PE Loading
- Parsing DOS headers, Nt Headers, Optional Headers 
- Walking entries in the DataDirectory 
- PE Loading 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Packers/Crypters

:::

<!-- element style="font-size: 24px"-->
- Static detection rules will help us identify static content in PEs. 
- We can no longer fully rely on them to detect the malware
- Since we can run a PE from memory, we can embed a compressed, and encrypted PE inside of another PE
- We can, however, use it to detect the stub that unpacks the malware
- Usually though, we want to unpack the malware to identify not just the packer but also the final payload 
- This also has implications in how First/second stage payloads work


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### UnPacking Malware

:::

<!-- element style="font-size: 24px"-->
- Let’s assume for now that the unpacked payload is  a .exe  PE. 
- Most stubs that unpack malware need to do the following
- Recover the raw PE Bytes (decompress, decrypt...etc)
- Allocate memory, some of which needs to be executable 
- Copy the PE into memory
- Resolve Import Address Table 
- Handle Relocations 
- TLS callbacks
- Pass execution to the entry point


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Unpacking: Useful Breakpoints

:::

<!-- element style="font-size: 24px"-->
- As always, look at the imports. There might, however, might not be any!
- If we can catch the loader/packer before it passes off execution, we can simply dump the PE from memory 
	- Note that the PE we dump might be memory mapped, in which case we will need to perform the opposite of what our loader does!
- Set a Breakpoint at VirtualAlloc(Ex), or other functions used to allocate memory (HeapAlloc, NtAllocateVirtualMemory...etc)
	-  Run until Return. The value in RAX will be the base address of the allocate memory 
	- Follow this address in dump and keep an eye on this until you see the sections 
opied into memory 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Matryoshka Dolls
:::

::: left
<!-- element style="font-size: 24px"-->
- Malware authors will routinely Compose Packers 
- This can get very annoying, very fast. 
- You can actually run the same packer multiple times. 
- For example, we can UPX pack our loader to load a UPX packed exe. 
- First,  we need to unpack the real loader, then we unpack the packed payload, then we can dump the actual payload 


:::

::: right
![[0x0d_3c72fd8a0dfc2c86_slide_7_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Building your own Packer

:::

<!-- element style="font-size: 24px"-->
- Compile a stub to unpack your code that decrypts, and decompresses data embedded in the PE. An example of this could be a resource file 
- Python pefile makes interacting with PE resources easy 
- This way, you can use python to compress and encrypt your payload, and you can embed the result as a resource in a fixed place.
- The primary purpose of a packer is two fold:
- 1) Hash Busting: old signatures no longer work on the packed malware. You can  (and should!) write yara rules for the stub-- but it is very easy to also hash bust the stub!
- 2) Frustrating the reverse engineer. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Automation

:::

<!-- element style="font-size: 24px"-->
- Scripting a debugger : set breakpoints at common functions found in Packers and scan memory for the magic MZ 
- Unpack.me: unpacking sandbox. Sadly for you all, it is 32bit only >:)
- PE-Sieve: incredible tool by Hasherezade that checks for injected PEs/Shellcode in a process 
- Writing a static unpacker for a specific packer you see a lot can take time, but depending on the circumstances could also be worth it!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Packers: Creating a Stub

:::

<!-- element style="font-size: 24px"-->
- The stub extracts the packed bytes from the PE, unpacks them, and loads  the PE
- There are many ways to create a stub, but they all will more or less look the same. 
- What will look different is where the PE bytes are stored, and how they are packed
- One option is to for a stub is to create an EXE that tries to load packed bytes that are stored in a resource 
- We can then simply  pack any PE, and embed it in the stub


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example Stub:

:::

<!-- element style="font-size: 24px"-->
- Stub loads packed PE bytes from a resource in the .rsrc data section
- The Packed PE bytes are compressed using windows LZMS (Windows version of LZMA)
- The stub needs to 
decompress
 the PE bytes
- Finally, the stub needs to load the PE file 
- Note that we could also store the bytes in the .data, .rdata, or a custom section. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Extracting Resources 

:::

<!-- element style="font-size: 24px"-->
- Call 
FindResource 
with the appropriate resource ID to get a handle to the resource
- Get a pointer to the raw bytes associated with the resource by calling 
LoadResource
- Optionally, lock the resource
- Get the resource size
- Decompress the bytes
- Call LoadPE
- Pass Execution to the entry point 


---
<!-- slide template="[[Title Slide]]" -->
 ## Manual Demo
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Meme
:::

::: left
<!-- element style="font-size: 24px"-->
- Laugh or I will fail you. 

:::

::: right
![[0x0d_3c72fd8a0dfc2c86_slide_14_image.png|170]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Working our way to Reflective DLL Injection

:::

<!-- element style="font-size: 24px"-->
- We currently have  method for loading a PE in a local process 
- The goal is to extend this to work for remote processes
- I.e., the same way that DLL injection forces a remote process to load a DLL from disk, we want to force a remote process to run a PE
- Eliminate the requirement of the PE exiting on disk 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reflective DLL injection

:::

<!-- element style="font-size: 24px"-->
- Copy a special DLL into a process' virtual address space
- This DLL  will have an exported function that is 
referred to as the reflective loader
- the reflective loader,will resolve imports, perform base  relocations, and pass execution as needed. 
It does all of this, without itself being a fully loaded ececutable! I.e., the reflective loader itself might as well be PIC


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### RDI
:::

::: left
<!-- element style="font-size: 24px"-->
- TLDR: Go load yourself 


:::

::: right
![[0x0d_3c72fd8a0dfc2c86_slide_17_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Process Injection: Key incredients
:::
<!-- element style="font-size: 24px"-->
### Most process injection requires the injector to 

1.  Allocate Read/Write/Executable memory in a remote processes’ address space    
2.  Copy the contents of th code into the remote buffer 
3.  Pass execution to the remote buffer


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Allocating Memory
:::
<!-- element style="font-size: 24px"-->
```c++

LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
);
```
The only difference between `VirtualAlloc` and `VirtualAllocEx` is we can now pass a handle to a process. When the function is called, the allocated memory will live in the remote process!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Copying Data
:::
<!-- element style="font-size: 24px"-->
We can’t  use memcpy, RtlMoveMemory, or something similar. We need to ask the kernel nicely to copy data from our Virtual Address space to the remote processes virtual Address space 
```c++
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```

Note that we need a pointer to  the start of our code, and the size of it!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Passing execution
:::
<!-- element style="font-size: 24px"-->
-   This is where you can extra get creative. The usual way of passing execution is to invoke CreateRemoteThread (as we did with DLL injection) 
-   Or you could use the native API call RtlCreateUserThread
-   A great talk from Black Hat lists multiple techniques for Process Injection
-   [https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf)



---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Fork and Run pattern
::: 


<iframe width="1180" height="664" src="https://www.youtube.com/embed/jVhMt26F7gA?start=26&end=37 " title="2 Chainz - Fork (Official Music Video) (Explicit)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Fork and Run

:::

<!-- element style="font-size: 24px"-->
- Fork and Run
: Spawn a sacrificial process
- The parent process gets a handle to the child process 
	- In many situations, it is better to create the processes in a suspended state
- From there, the shellcode/PE is copied into the child processes’ 
virtual
 address space from  the parent process 
- Execution is passed to the injected code 
	- Optionally, if the Process was created in a suspended state, you resume the process 


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: Shellcode Injection 1
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Why do we bother with Injecting DLLs

:::

<!-- element style="font-size: 24px"-->
- Writing shellcode is (in my opinion) difficult 
- Injecting shellcode is easy 
- Injecting PEs is a little harder 
- See  the following for solutions to convert PEs into shellcode!
- https://github.com/TheWover/donut
- https://github.com/monoxgas/sRDI

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Outstanding items

:::

<!-- element style="font-size: 24px"-->
- Before we are ready for rDLL injection, we need to to figure out how to call LoadLibraryA and GetProcAddress in a remote process for DLLs that might not exist on disk!
- There are many ways to 
accomplish
 this. If you’r code only relies on Kernel32.dll you could patch the IAT before injecting as the base address of Kernel32.dll will be the same for all processes! 
- Because of ASLR though, this will not work for DLLs that have been relocated 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Definitions 

:::

<!-- element style="font-size: 24px"-->
- PE file bytes: the bytes as they exist before the PE is mapped into memory
- File Offset: assuming the bytes exist in a contiguous array, the offset is the index in the array 
- Virtual Memory: the interface that userland processes are given to interact with physical memory. Note there isn’t actually 2^64 bytes of memory available. The OS is a dirty, dirty liar. 
- Virtual Address: the location in virtual  memory
- Relative Virtual Address (RVA): The offset of an object from its base address (RVA = VA - BaseAddress)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reflective DLL Injection

:::

<!-- element style="font-size: 24px"-->
- Inject (file bytes) DLL into a Process 
- The DLL exports a special function that loads itself even before it is memory mapped
- Execution is past back to the caller


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Review: Improved DLL Injection

:::

<!-- element style="font-size: 24px"-->
- Call LoadLibraryA in our own process to load the dll to inject 
- Call GetProcAddress to find the Address of the Exported function 
- Compute the offset by subtracting the VA of the exported function from base address of the loaded library 
- Force Remote Process to  call LoadLibraryA  to load the DLL
- Compute the VA of the exported function (RVA + ImageBase) in the remote process 
- Pass Execution to the exported function in the remote process at the VA of the exported function. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### RDI→  Injection

:::

<!-- element style="font-size: 24px"-->
- The way we inject into a remote process is nearly identical to Dll injection
- Get a handle to the remote process
- Copy the bytes of the DLL into the remote process
- Calculate the offset of the reflective loader by walking the export table 
- Technically, this can be computed offline 
- Pass execution to the reflective loader
- The reflective loader resolves imports, performs base relocations, executes TLS callbacks, and invokes DLLMain. 
- Call Exported function

---
<!-- slide template="[[Title Slide]]" -->
 ## Walking the Export Directory Table 
---
<!-- slide template="[[Title Slide]]" -->
 ## Offsets vs RVAs
---
<!-- slide template="[[Title Slide]]" -->
 ## LoadLibraryR
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Injection 

:::

<!-- element style="font-size: 24px"-->
- Get a pointer to the start of the PE file bytes
- Compute the offset of the reflective Loader 
- Get a handle to the target processes 
- Allocate Memory in the target process 
- Copy the PE bytes to the target processes 
- Allocate an additional space needed for arguments if using a thread 
- Copy the arguments 
- Pass execution 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reflective Loader

:::

<!-- element style="font-size: 24px"-->
- Doesn’t have access to the IAT! 
- Is responsible for loading the DLL (i.e., itself!)
- Has no idea where it is in memory 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Computing Module BaseAddr

:::

<!-- element style="font-size: 24px"-->
- Options:
Just scan memory until we find the special PE\0\0 signature
- Pass it as an argument 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Finding the Base of Kernel32.dll

:::

<!-- element style="font-size: 24px"-->
- We need to find kernel32.dll so we can find the address of 
- LoadLibraryA, and Get ProcAddress
- We can then use them to find VirtualProtect and VirtualAlloc
- This is all that is needed to load a PE

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PEB/TEB

:::

<!-- element style="font-size: 24px"-->
- Execute a special windows assembly instruction to get the address of a per-process data structure that can be used to enumerate loaded modules, including kernel32.dll
- TLDR:
- TEB->PEB->Ldr->InMemoryOrderLoadList->currentProgram->ntdll->kernel32.BaseDll
- For more, see 
https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### SEH

:::

<!-- element style="font-size: 24px"-->
- Randomly
 scan memory and catch access violations (slow but technically does work)
- Or, Get the base address of KERNEL32.DLL through SEH(FS:[00])
- For more, see 
https://blog.actorsfit.com/a?ID=00550-40d236ad-6dfa-4b75-9765-7c11b92838a8

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Passing it!

:::

<!-- element style="font-size: 24px"-->
- The injecting process, depending on the method of execution, can pass the base address of kernel32.dll to the injected process.
	- This works because kernel32.dll will be mapped to the same virtual address for each processes
	- Note that because of ASLR, this base address of kernel32.dll (and also ntdll.dll) will be different  each time the machine restarts but will be the same for all processes once the computer boots!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Finding our Base Address 

:::

<!-- element style="font-size: 24px"-->
- MOV RAX [RSP]
- VC++: 
_ReturnAddress
- MinGW 
__builtin_extract_return_addr
__builtin_return_address
- Then just walk backwards until we find our magix MZ\0\0


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with LoadLibrary + strings

:::

<!-- element style="font-size: 24px"-->
- The compiler might choose to put your strings in .rdata/.data 
- While you can  use integers/assembly to put the name of the functions inside of the .text section, it is usually easier to put a hash function in the loader, and hardcode the hash of the exported function
- Then use the hash to find it by walking the export table 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Detecting RDI
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x0d_3c72fd8a0dfc2c86_slide_44_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Detecting Injection: Process Monitor
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x0d_3c72fd8a0dfc2c86_slide_45_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What comes next?

:::

<!-- element style="font-size: 24px"-->
- More 
advanced
 injection/hollowing 
- In-process injection 
- Object files, COFF loaders
- Weird machines 
- Random file formats 



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What comes next?

:::
Advanced: no more fork and run :-)

 
<iframe width="1180" height="664" src="https://www.youtube.com/embed/xQGBW7Yf6lo?start=39&end=41&loop=1" title="Kevin Gates - I Don&#39;t Hit It With The Fork" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>