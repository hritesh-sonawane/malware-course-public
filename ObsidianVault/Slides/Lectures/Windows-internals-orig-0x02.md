---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### CS-501

:::

<!-- element style="font-size: 24px"-->
- Introduction to Malware, Threat Hunting & Offensive Capabilities Development


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x02: 
Basic Windows Internals

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### (Some) Windows Design Principles

:::

<!-- element style="font-size: 24px"-->
- Extensibility
- Portability
- Reliability  
- Performance
- Compatibility
- Security 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Extensibility 



:::

<!-- element style="font-size: 24px"-->
- The bulk of system services are provided by the Executive
- The Windows OS is technically a monolithic OS
	- I.e., One driver can mess with another driver. Kernel memory is shared 
- However, it 
separates
 userland execution 
environments
 into “subsystems”
- Each subsystem has the ability to execute a type of application
- This provides a modular setup where changes to execution 
environments
 don’t 
necessarily
 necesitate changes to the executive 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Portability

:::

<!-- element style="font-size: 24px"-->
- Windows will run on a wide variety of systems. 
- The bulk of the OS is written in C and C++
	- The rest is bundles of code used for processor specific instructions (Eg Arm vs intel/amd)
- Platform dependent code is implemented in the Hardware Abstraction Layer (HAL)
- - This is less magical than it was 10 years ago as most modern OSes support variety in hardware/architecture


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reliability

:::

<!-- element style="font-size: 24px"-->
- User applications should not be able to 
corrupt
 the operating system
- Windows audits most drivers and has rigorous standards for which drivers are officially signed
- That said, malicious drivers can muck around with kernel memory. There are countermeasures for this. (eg Driver Guard)

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Performance
:::

::: left
<!-- element style="font-size: 24px"-->
- Should be fast. 


:::

::: right
![[0x02_slide_13_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Compatibility

:::

<!-- element style="font-size: 24px"-->
- Backwards compatibility and extending of existing technology
- This is partially why the Windows API is so stable 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Security

:::

<!-- element style="font-size: 24px"-->
- Kernel/User separation 
- User separation
- Process (and associated resources) isolation 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows Kernel

:::

<!-- element style="font-size: 24px"-->
- Windows is an Object based kernel
- Resources are called objects, and can only be directly accessed by the kernel
- To indirectly interact with an object, a 
handle
 is used

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel Objects

:::

<!-- element style="font-size: 24px"-->
- Kernel object (KOs): a single run-time instance of a statically defined object type 
- Object types are system-defined data types. 
- Each object type has its own attributes and functions to interact with it
- For example, an object of type 
process 
is an instance of a process object.
- file 
object is an instance of a file. Note, 
file!= a thing on disk


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Objects and Handles 

:::

<!-- element style="font-size: 24px"-->
- A handle is an abstract reference to an object. This could be an actual pointer to the object, or a reference to a per-process GUID that references an object
- This allows us to abstract away direct management of objects in memory, and instead work with with references. 
This is a security control. If something goes wrong in kernel space, you get a BSOD. 
- APIs are used to interact with system resources, share resources among processes, and protect resources from unauthorized access.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows System Architecture

:::

<!-- element style="font-size: 24px"-->
- User Processes
- Subsystem DLLs
- NTDLL.dll
- Service Processes
- Executive
- Kernel 
- Device Drivers
- Win32k.sys
- (sometimes) Hyper-V


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Interacting with the Windows OS

:::

<!-- element style="font-size: 24px"-->
- Windows API functions (win32): Documented, callable functions in the Windows API. 
	- For example, MessageBox, CreateFile, GetMessage
- Native system services (sys calls): Undocumented (officially) underlying serivices in the OS that are callable from user mdode. For example 
	- NtAllocateVirtualMemory is the internal service used for VirtualAlloc 
	- NtCreateUserProcess is the internal service used by CreateProcess
- Direct Syscalls
- Other:  (WinRT, COM,...etc)
- Kernel support functions: functions inside the Windows OS that can only be called from in kernel mode

---
<!-- slide template="[[Title Slide]]" -->
 ## Windows Executables and Shared Libraries 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Executable File Formats

:::

<!-- element style="font-size: 24px"-->
- Bundles of machine code and associated data needed to run a program
- Usually requires an OS to 
load
 the executable
- Code is organized according to a convention that the programer and the kernel agree on. 
- It is just a convention though!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format Basic Definitions and Concepts 

:::

<!-- element style="font-size: 24px"-->
- Portable Executable (PE) is an executable file format used by Windows NT
- It contains information about code to execute, and how it should be executed
- In this discussion, we will use an open source tool PE-Bear to look at the structure of a PE file.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE File Format 

:::

<!-- element style="font-size: 24px"-->
- PE file format is used for both userland and kernel mode executables
	- Userland: file.exe, file.dll, file.obj 
	- Kernel mode: driver.sys, ntoskrnl.exe 
- PE is  based on the Common Object File Format (COFF).
- PE format is not architecture specific (hence “portable”)
	- Note this means the format can be used across multiple different architectures. The  target architecture is still specified inside of the PE though
- Data is grouped together in blocks called 
sections
, identified by 
headers


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE: Libraries

:::

<!-- element style="font-size: 24px"-->
- Windows shared libraries are called Dynamically Linked Libraries
- They are PE files with a special characteristic set
- They can export functions from their code
- Other PEs can load these libraries and access the exported code
- This allows for modular programs
- - We will talk more about this next lecture when we review linking. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE

:::

<!-- element style="font-size: 24px"-->
- PEs are composed of sections and headers
- Sections are data/code
- Headers contain information about how to load the PE, and where the data is, and how to process it 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Tools

:::

<!-- element style="font-size: 24px"-->
- In this lecture, we will use PE-Bear to explore the PE file format. 
- As a sample, lets use Calc.exe (64 bit)
- Run $path = Get-Command calc.exe to find the path to calc.exe on your machine
- Run PE-Bear.exe $path.Source  (in powershell)

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Calc.exe
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x02_slide_28_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DOS Header
:::

::: left
<!-- element style="font-size: 24px"-->
- The DOS header contains the magic bytes MZ that identify it as a PE
- The final entry (offset 0x3c referenced as ->e_lfanew) is the offset the of NT Headers

:::

::: right
![[0x02_slide_29_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### NT Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Signatures
- File Header
- Optional Header


:::

::: right
![[0x02_slide_30_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Signature
:::

::: left
<!-- element style="font-size: 24px"-->
- Usually 4 bytes containing 
- “PE\0\0”
- For our purposes, it is only used to verify the file format. 

:::

::: right
![[0x02_slide_31_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### File Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Following the Signature, we have the File Headers. This gives us
- The number of sections (NumberOfSections)
- Whether or not we have a DLL/EXE (Characteristics)
- The Compilation timestamp 
- A pointer to a symbol table if one exists 


:::

::: right
![[0x02_slide_32_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- I don’t know why it is listed as optional. I don’t think a PE can run without this section (but I could be wrong?)
- The optional headers contains most of  the data required to load PE
- Specifically, values found here are used to build the 
Import Address Table
, and perform 
Base Relocations


:::

::: right
![[0x02_slide_33_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 1)
:::

::: left
<!-- element style="font-size: 24px"-->
- Magic: Architecture of image
- Entry Point: Relative virtual address (RVA) from the Base Address
- Image Base: (prefered) Base address: Where in memory the PE “prefers” to be loaded. If the location is unavailable, the Image needs to be relocated 

:::

::: right
![[0x02_slide_34_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 2)
:::

::: left
<!-- element style="font-size: 24px"-->
- SizeOfImage: the virtual size of the image 
- SizeOfHeaders: the size of the headers
- DLLCharacteristics: flags including knowledge of hardening features such as ASLR/ CFG...etc. Not super important for us other than assuming knowledge of ASLR. 


:::

::: right
![[0x02_slide_35_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Sections

:::

<!-- element style="font-size: 24px"-->
- .text Executable code (machine instructions)
- .data: global variables
- .rdata: read only global variables


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamically Linked Libraries: 

:::

<!-- element style="font-size: 24px"-->
- Refresh: What is a DLL?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DLL

:::

<!-- element style="font-size: 24px"-->
- A PE with with DLL characteristic field set. 
- Usually it has exported functions which can be referenced by code outside of the DLL
- The Windows API is implemented in a handful of DLLs that export specific functions

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Win32 API	

:::

<!-- element style="font-size: 24px"-->
- We will mostly leverage documented functions from the Windows API
- The function definitions are well documented
- Reading that documentation however, is a skill that must be learned
- Sometimes, we need more control over what we are trying to accomplish, and will leverage undocumented functions stored in NTDLL.dll


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NtDLL.dll	

:::

<!-- element style="font-size: 24px"-->
- Implements the Windows Native API. This is the lowest layer of code that is still Userland code. 
- It is used to communicate with the kernel for system call invocation. 
- NtDLL also implements the Heap Manager, the (executable) Image loader and some of userland thread pools. Every process loads this DLL in the same location in memory! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel32.dll

:::

<!-- element style="font-size: 24px"-->
- Contains (more or less) the same functionality as NtDLL!
- It exposes basic operations such as memory management, input/output (I/O) operations, process and thread creation, and synchronization functions
- It can be thought of as a compatibility layer, as it almost always calls directly into NTDLL.dll
- This is to maintain backwards compatibility– where the Win32 API rarely changes, but the Native API changes from release to release.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### 32bit vs 64bit	

:::

<!-- element style="font-size: 24px"-->
- This class will focus on 64bit executables (Intel x86 64)
- When developing code that needs to run on either a 32bit or 64bit systems, you need to take care when assuming the size of various types. For example, type sizes vary across 32bit and 64bit architectures and you need to take care when defining them. 


---
<!-- slide template="[[Title Slide]]" -->
 ## Processes
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Processes

:::

<!-- element style="font-size: 24px"-->
- Nothing in userland is executed outside of the context of a process.
- You don’t “run a processes”
- You run threads 
- Processes are containers, and there is no such thing (to my knowledge) as code running outside of a process

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Threads 

:::

<!-- element style="font-size: 24px"-->
- Unit of execution contained within a process 
- Actual entity that executes code 
- More on threads in later. For now, we will only deal with processes that have a single executing thread.


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Process Resources 
:::

::: left
<!-- element style="font-size: 24px"-->
- Uniquely identified by a Process ID
- Contains a security context in the form of a Process Access Token
- Maintains a table of handles to objects
- Has a 
private
 virtual address space 
- >=1 Thread (possibly with its own token)

:::

::: right
![[0x02_slide_46_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Virtual Memory

:::

<!-- element style="font-size: 24px"-->
- An abstraction layer around physical memory
- Each process gets its own private virtual memory 
- 2^32 bytes worth on 32 bit (possibly more with some extensions) 
- 2^64 bytes worth on 64 bit
- The kernel lies about how much space there really is
- Think of a virtual address space as a giant, contiguous array of bytes


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Process Virtual Memory
:::

::: left
<!-- element style="font-size: 24px"-->
- Windows 
implements
 a linear Virtual Address space
- Provides a logical interface for a process to interact with indirectly with 
physical
 memory

:::

::: right
![[0x02_slide_48_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Memory Layout	
:::

::: left
<!-- element style="font-size: 24px"-->
- Each processes gets its own 
Virtual Address Space
- The Windows OS divides Virtual Address space into  two portions: kernel and Userland*
- Memory here grows “downward” from higher address spaces to lower address spaces
- On x64, the upper half is reserved for kernel space and the bottom half is reserved for processes

:::

::: right
![[0x02_slide_49_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory

:::

<!-- element style="font-size: 24px"-->
- Virtual: A Block of raw memory 
- Stack: technically can be managed by the programmer but is usually managed by the processes and the compiler
- Heap Memory: managed by the programer with a special data structure called a Heap (Basically a priority queue)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack: what is it good for?

:::

<!-- element style="font-size: 24px"-->
- Local variables
- Passing arguments to a function
- Returning values from a  function 
- Function invocation/ABI

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Data structure built on top of our Virtual Address Space that allows us to Push, and pop values from a stack
- Whenever we invoke a function with 
call 
 a new 
stack frame
 is created. We call this the function call stack
- This is a contiguous chunk of memory that acts as a working space for a function’s duration

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Stack memory is temporary: once the function returns the memory is reclaimed
- Still error prone but is typically safer and faster than Heap allocations  
- A programer usually does not need to worry about managing stack memory
- We need to know how much is needed at compile time!


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Heap Allocation

:::

<!-- element style="font-size: 24px"-->
- Allows for dynamic allocation sizes. 
- Recall we don’t need to know how much memory is needed at compile time
- Heap memory is managed by a heap allocator. 
- The programmer allocates with a call to malloc and frees the memory with a call to free
- If the programer forgets to call free, that memory is now unusable until the process terminates and we have introduced a 
memory leak


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Heap Memory
:::

::: left
<!-- element style="font-size: 24px"-->
- Memory that can be allocated/deallocated at runtime
- Used for data whose size is not known at compile time
- Slower than stack 


:::

::: right
![[0x02_slide_55_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Process Creation	

:::

<!-- element style="font-size: 24px"-->
- Somewhat complicated. We will simplify it for this class, than dive into it next class after we talk about handles. 
- Kernel opens the image (executable file) and verifies it is the correct format
- The kernel creates a new process kernel object and a thread kernel object
- The kernel maps the image to an address space, as well as ntdll.dll 
	- Note this gets mapped to just about every type of process
- The creator process notifies Windows subsystem process (Csrss.exe) that a new process and thread have been created
- From the kernel’s perspective, the process is created at this point 
- Some magic happens,  imports are resolved and after all the required LLs are declared, we reach the entry point and the program starts 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Basic Information of a Process

:::

<!-- element style="font-size: 24px"-->
- Name: Usually the executable name. This is NOT a unique identifier 
- Process ID (PID: Unique ID of a process. PIDS are reused after a process terminates
- Status: Running, Suspended, Not Responding 
- Username: the user who is running the process. It also includes the primary token that holds the security context for the user
- Session ID: Session number under which the process executes. Session 0 is for system processes and services. Session 1 and higher are used for interactive logins.

