---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::



---
<!-- slide template="[[Title Slide]]" -->
 ## PE Loaders
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Agenda

:::

<!-- element style="font-size: 24px"-->
- PE File Format (review)
- PE Loading 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE Loading 

:::

<!-- element style="font-size: 24px"-->
- Memory Mapping headers and sections
- Building the Import Address Table
- Handling Base Relocations 
- Executing TLS Callbacks 
- Passing Execution 
- Note 2 & 3 can be be performed interchangeably  


---
<!-- slide template="[[Title Slide]]" -->
 ## Memory Mapping a PE
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Review 

:::

<!-- element style="font-size: 24px"-->
- File Address: the offset from the start of the file as the PE appears on Disk. 
- PEs are composed of Headers and sections 
- Headers tell you where data is 
- Sections contain data 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Tools

:::

<!-- element style="font-size: 24px"-->
- In this lecture, we will use x64dbg, and PE-Bear to explore the PE file format. 
- As a sample, lets use Calc.exe (64 bit)
- Run ``$path = Get-Command calc.exe to find the path to calc.exe` on your machine
- Run `PE-Bear.exe $path.Source`  (in powershell)

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory Mapping a PE: Step 1

:::

<!-- element style="font-size: 24px"-->
- Load the **File bytes** of the PE into  a contiguous chunk of memory
- Note this can be loading a PE from disk, downloading it from the internet, retrieving it from a section of a PE…etc
- Python pseudo code:

```python
with open("foo.exe", "rb") as f:
	file_bytes = f.read()
```


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory Mapping a PE: Step 2


:::

<!-- element style="font-size: 24px"-->
- Parse the Headers: this will tell you how to parse the rest of the PE!
- Use the DOS Header to find the NT Headers
- Use the NT headers to find the optional headers 

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Calc.exe
:::


![[0x0c_b6b4ef3d71bb2a6d_slide_11_image.png|300]]



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DOS Header
:::

::: left
<!-- element style="font-size: 24px"-->
- The DOS header contains the magic bytes MZ that identify it as a PE
- The final entry (referenced as ->e_lfanew) is the address of NT Headers
- The next block of bytes contain the DOS stub 


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_12_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Working with C/C++

:::

<!-- element style="font-size: 24px"-->
- There are several  structures we can use to parse the bytes
- We will assume that the Executables are all 64bit, but with a little bit of care, we can make our code work for 32bit and 64 bit PEs. (Note that we need a 32 bit exes to launch 32 bit applications. Same for 64 bit) 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DOS Header:

:::

<!-- element style="font-size: 24px"-->
```c
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 
```


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DOS Header

:::

<!-- element style="font-size: 24px"-->
- If we have a pointer to the start of our PE Bytes, we can simply set the start of a DOS_HEADER struct to our PE bytes
- Defined in <winnt.h>
- LONG
e_lfanew
                    // File address of new exe header
- The offset above gives us the start address of the NT Headers

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Headers 

:::

<!-- element style="font-size: 24px"-->
- To calculate the **file address* of the NT Headers, we add the offset e_lfanew to the base file address
- I.e. if the value of e_lfanew is X, and the start memory address of our PE buffer is Y, then the address of the beginning of the NT Headers struct is Y + X


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### NT Headers
:::

![[0x0c_b6b4ef3d71bb2a6d_slide_17_image.png]]




---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### NT Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Signatures
- File Header
- Optional Header


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_18_image.png]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Signature
:::

::: left
<!-- element style="font-size: 24px"-->
- Usually 4 bytes containing 
- “PE\0\0”
- For our purposes, it is only used to verify the file format. 

:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_19_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### File Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- Following the Signature, we have the File Headers. This gives us
- The number of sections (NumberOfSections)
- Whether or not we have a DLL/EXE (Characteristics)
- The Compilation timestamp

:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_20_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers
:::

::: left
<!-- element style="font-size: 24px"-->
- I don’t know why it is listed as optional. I don’t think a PE can run without this section (but I could be wrong?)
- The optional headers will contain the data 
required
 to load the PE
- Specifically
, we will use values found here to build the IAT, and perform Base Relocations


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_21_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 1)
:::

::: left
<!-- element style="font-size: 24px"-->
- Magic: 
Architecture
 of image
- Entry Point: Relative virtual address (RVA) from the Base Address
- Image Base: (prefered) Base address: Where in memory the PE “
prefers
” to be loaded. If the location is 
unavailable
, the Image needs to be relocated 

:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_22_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Optional Headers (pt 2)
:::

::: left
<!-- element style="font-size: 24px"-->
- SizeOfImage: the virtual size of the image 
- SizeOfHeaders: the size of the 
headers
- DLLCharacteristics: flags including knowledge of hardening features such as ASLR/ CFG...etc. Not super important for us other than assuming knowledge of ASLR.


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_23_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Headers

:::

<!-- element style="font-size: 24px"-->
- IMAGE_NT_HEADERS is actually  a macro that expands to the relevant Struct for 32bit PEs and 64bit PEs respectively
- 32 bit: 
IMAGE_NT_HEADERS32
- 64 bit: IMAGE_NT_HEADERS64

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Headers 64 bit

:::

<!-- element style="font-size: 24px"-->
```c
typedef struct _IMAGE_NT_HEADERS64 {
  DWORD                   Signature;
  IMAGE_FILE_HEADER       FileHeader;
  IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Header → FileHeader

:::

```c
typedef struct _IMAGE_FILE_HEADER {
  WORD  Machine;
  WORD  NumberOfSections;
  DWORD TimeDateStamp;
  DWORD PointerToSymbolTable;
  DWORD NumberOfSymbols;
  WORD  SizeOfOptionalHeader;
  WORD  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Header → FileHeader


:::

<!-- element style="font-size: 24px"-->
- We need to Parse the 
- Machine
 to ensure we have the correct Arch
- `NumberOfSections`: this allows us to iterate through all sections of the PE

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### NT Headers → OptionalHeaders

:::
<!-- element style="font-size: 20px"-->
```c
typedef struct _IMAGE_OPTIONAL_HEADER64 {
  WORD                 Magic;
  BYTE                 MajorLinkerVersion;
  BYTE                 MinorLinkerVersion;
  DWORD                SizeOfCode;
  DWORD                SizeOfInitializedData;
  DWORD                SizeOfUninitializedData;
  DWORD                AddressOfEntryPoint;
  DWORD                BaseOfCode;
  ULONGLONG            ImageBase;
  DWORD                SectionAlignment;
  DWORD                FileAlignment;
  WORD                 MajorOperatingSystemVersion;
  WORD                 MinorOperatingSystemVersion;
  WORD                 MajorImageVersion;
  WORD                 MinorImageVersion;
  WORD                 MajorSubsystemVersion;
  WORD                 MinorSubsystemVersion;
  DWORD                Win32VersionValue;
  DWORD                SizeOfImage;
  DWORD                SizeOfHeaders;
  DWORD                CheckSum;
  WORD                 Subsystem;
  WORD                 DllCharacteristics;
  ULONGLONG            SizeOfStackReserve;
  ULONGLONG            SizeOfStackCommit;
  ULONGLONG            SizeOfHeapReserve;
  ULONGLONG            SizeOfHeapCommit;
  DWORD                LoaderFlags;
  DWORD                NumberOfRvaAndSizes;
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

```


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Optional Headers → ___

:::

<!-- element style="font-size: 24px"-->
- There is a lot going on in this structure but lets gleam a few important values from it that will come in handy:
- `ImageBase`: a memory address (
preferred
) to load the image at. If we can’t load the PE here, we should load it somewhere else.
- `AddressOfEntryPoint`: the RVA of the PE’s entry function. (I.e., ImageBase + AddressOfEntryPoint → Virtual Address of the entry point  
- SizeOfHeaders: the size of the PE’s headers 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Load a PE

:::

<!-- element style="font-size: 24px"-->
- Get a pointer to the start of your PE Bytes.
- Parse the DOS Header, and the NT Header
- Map the  PE into Memory 
- Resolve Imports
- Perform Base Relocations 
- Fix Section Memory Protections (technically optional but you shouldn’t mark everything as R/W/X)
- Pass execution to the entrypoint 
- Note steps 2 and 3 can be 
interchanged


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Mapping the PE into Memory

:::

<!-- element style="font-size: 24px"-->
- From the optional Headers, we know the size of the PE is ntHeader
 OptionalHeader-->SizeOfHeaders
- We can use this to Allocate enough memory to hold all of the sections of our PE

```c
 BYTE* ImageBase =  (BYTE*)VirtualAlloc(NULL, 
    sizeOfImage, 
    MEM_RESERVE | MEM_COMMIT, 
    PAGE_READWRITE 
    );

```
- This gives us a pointer to a buffer in memory that we can read from and write to. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Breaking down the VirtualAlloc Args

:::

<!-- element style="font-size: 24px"-->
- NULL: I want the OS to figure out where in virtual memory to give me space. Alternatively, we could pass in a specific address. 
- sizeOfImage: how many bytes I want
- MEM_RESERVE | MEM_COMMIT:  reserve the contiguous memory, and ensure it is filled with 0s. Distinction between reserving and committing is a bit technical, so we 
omit
details
. But these are usually the parameters you want when calling VirtualAlloc
- PAGE_READWRITE: I want to be able to read from  and write to this block of memory


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Mapping Sections 

:::

<!-- element style="font-size: 24px"-->
- Recall that our PE has a 
preferred
  base address. 
- Since ASLR is enabled on most systems, there is a chance the address is un
available
- We could make a call to VirtualAlloc with the 
preferred
 base address, check if it fails than set the 
parameter
 to NULL but in my 
experiment
, we 
rarely
 get our desired address. 
- For simplicity, I skip this extra step, but just know we are deviating from what the actual PE loader does. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Mapping the PE into Memory

:::

<!-- element style="font-size: 24px"-->
- First, we need to copy the headers of the PE. 
- The first X bytes of the PE are the PE headers
- X is located in the optional Header under SizeOfHeaders
- To map the headers into memory, we simply copy X bytes starting at the 
beginning
 of the PE bytes, into the first X bytes of the newly allocated Buffer 


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Copying The Headers into Memory
:::

![[0x0c_b6b4ef3d71bb2a6d_slide_35_image.png]]




---
<!-- slide template="[[Title Slide]]" -->
 ## PE Sections
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### PE Sections Struct 

:::

```c
typedef struct _IMAGE_SECTION_HEADER {
  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];
  union {
    DWORD PhysicalAddress;
    DWORD VirtualSize;
  } Misc;
  DWORD VirtualAddress;
  DWORD SizeOfRawData;
  DWORD PointerToRawData;
  DWORD PointerToRelocations;
  DWORD PointerToLinenumbers;
  WORD  NumberOfRelocations;
  WORD  NumberOfLinenumbers;
  DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Copying The Sections into Memory

:::

<!-- element style="font-size: 24px"-->
- We must now iterate over each section (i.e. .text .data .rdata ...etc) and map it into memory at the correct offset in our newly allocated buffer 
- The sections should come after the header
- Sections are also structs whos definitions can be found in winnt.h

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Iterating over Sections

:::

<!-- element style="font-size: 24px"-->
- There is a handy macro that will give us the address of the first section: 
IMAGE_FIRST_SECTION()
- This macro returns a pointer to an array of Image sections
- We retrieved the number of sections in the previous step, and we can now iterate

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Copying Sections 

:::

<!-- element style="font-size: 24px"-->
- For each section struct, we need to get
- The VirtualAddress: RVA of the section
- PointerToRawData: a pointer to the section bytes
- SizeOfRawData: the number of bytes in the section 
- Add the RVA to the base address of the PE to get a pointer to the start of this section.
- Copy SizeOfRawData bytes from PointertoRawData to BaseAddress + RVA
- The Characteristic value also tells us what memory protection is 
required
 for the section


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Handling Imports 
:::

::: left
<!-- element style="font-size: 24px"-->
- Now that we have all of 
our sections mapped into memory, it is time to build the IAT
- The Imports are described in the PE Header inside of the Optional Header
- The Data Directories is struct corresponding to a table


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_41_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Building the IAT
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### IAT

:::

<!-- element style="font-size: 24px"-->
- Recall that the Import Address Table (IAT) is a table of function pointers
- These function pointers are references to functions from loaded Libraries 
- The notation we use to reference a function from a DLL is with a $
- I.e. user32.dll$MessageBoxA

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Building up the IAT
:::

::: left
<!-- element style="font-size: 24px"-->
- We locate the Import Address Table by parsing the optional headers, which contains the data directory 
- The DataDirectory is an array of IMAGE_DATA_DIRECTORY structure
- typedef
struct
_IMAGE_DATA_DIRECTORY
- DWORD
VirtualAddress
- DWORD
Size
- IMAGE_DATA_DIRECTORY
PIMAGE_DATA_DIRECTORY


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_44_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Getting the Import Address table

:::

<!-- element style="font-size: 24px"-->
- Given the start address of the DataDirectory (cast as the correct type), we can reference the start of the Import Address Table 
	- ntHeaders
OptionalHeader
DataDirectory
IMAGE_DIRECTORY_ENTRY_IAT
- The IAT contains the functions 
address
, but we don’t know which entry the function pointer belongs to
- This information is contained elsewhere 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Import Directory Table

:::

<!-- element style="font-size: 24px"-->
- The IDT is a null 
terminated
 array of IMAGE_IMPORT_DESCRIPTOR structs
- I sometimes 
absent
mindedly
 call this the Import Descriptor Table 
(which is NOT a thing)
, because it contains the 
descriptions
 of required modules 
- The Import Directory table, contains entries for modules loaded by the image
- The Loader uses this table to build the IAT with function pointers to absolute  Virtual Addresses.
- Recall these entries should point to the correct offset in a loaded DLL
- TLDR: this is where we find our null terminated array of DLLs required by our PE

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Import Lookup Table 

:::

<!-- element style="font-size: 24px"-->
- The ILT is also a null 
terminated
 array of  IMAGE_THUNK_DATA structs
- IMAGE_THUNK_DATA expands to IMAGE_THUNK_DATA32/64 depending on the architecture.
- These structs contain the functions within the DLL  that we  need to load.

```c
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;
```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### ILT Parsing

:::

<!-- element style="font-size: 24px"-->
- The ILT can 
specify
 imported functions by either Name or Ordinal value
- For 
ordinal
 fields, the union in IMAGE_THUNK_DATA will have the most 
significant
 bit set to 1
	- In the above case, we can extract the the ordinal name from the least 
significant
 bytes
- If the bit is not set,  the name of the function is contained in an IMAGE_IMPORT_BY_NAME struct 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Data Directories 

:::

<!-- element style="font-size: 24px"-->
- The directories appear in a fixed order, (Export Directory <*> followed by Import Directory <*> followed by Resource Directory <*>...etc)
- The values in the Data directory that we need to read/modify are 
- The import directory
- Import Address Directory Table (IDT) 
- Import Address Table (IAT)

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Data Directories

:::

<!-- element style="font-size: 24px"-->
- The IDT 
gives us information about what imports are required for the PE to load
- The IAT provides the programer an interface to reference an RVA that will contain a trampoline to the actual address of the imported function at run time. 
- The Import Directory RVA points to a NULL terminated array of  IMAGE_IMPORT_DESCRIPTOR structs 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### IMAGE_IMPORT_DESCRIPTOR


:::
<!-- element style="font-size: 24px"-->
```c
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)
    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;


```


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Iterating over Libraries 

:::

<!-- element style="font-size: 24px"-->
- For each Image import descriptor, attempt to get a handle to the library. If this fails, panic.
- Add the data directories IMAGE_DIRECTORY_ENTRY_IMPORT RVA to the base address to get the start of the NULL terminated array of IMAGE_IMPORT_DESCRIPTOR structs 
- We must now walk this array. 
- Each Image Descriptor will have a
-  → Name (the DLL to load)
- → IMAGE_THUNK_DATA* which points to “THUNK” (functions resolved at a later date) 
- Call LoadLibraryA on → Name 
- For each image descriptor, we must now iterate through the list of functions required for that library


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Iterating over Functions in a Module

:::

<!-- element style="font-size: 24px"-->
- Parse the OriginalFirstThunk and FirstThunk  entry points for this library
- These entries are both null terminated 
IMAGE_THUNK_DATA 
 structs.
- The OriginalFirstThunk entry points to an array of references to the functions to import from the external library. This is exactly the Import Lookup Table.
- FirstThunk points to a list of addresses that gets filled with pointers to the imported symbols. This is exactly the import Address table.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### IMAGE_THUNK_DATA

:::

<!-- element style="font-size: 24px"-->
- Also a macro that expands to the 32bit/64bit version 

```c
typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PDWORD
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;


```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Image thunk Data

:::

<!-- element style="font-size: 24px"-->
- We recover the function name either via Ordinal or via Name. 
- We read the function name from  our lookup table, as well as the RVA 
- The Function field  needs to be patched with the functions address 
- We call GetProcAddress (eiter on the ordinal or the Name) and set the value of the lookup table to the address of the loaded function 
- Repeat this for each function, and each library! 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Debugging

:::

<!-- element style="font-size: 24px"-->
- Tips for Debugging: 
- Look at the entry point of the PE you are loading. 
- Notice the 
symbols
 you see for functions are actually references to the IAT 
- Break at the entrypoint of the manually loaded PE and compare it to the 
legitimately
 loaded PE
- If these symbols differ, the IAT was not created properly 
- Example: detecting (an actual bug) that ate my Wednesday night. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Tips

:::

<!-- element style="font-size: 24px"-->
- Breakpoint at VirtualAlloc
- MessageBoxA ← just put these wherever you want to break at. Or you can compile with symbols/Configure VSCode. 
- Breakpoint
 at CreateThread/However you pass execution. 
	- Set a breakpoint at the entry point (in this case, register R8 should have the address of the entry point) 
- Ctrl-f9 (execute until function return) is your friend! 
- F8  step over a function call (run until return then call ret) 
- F7 step into (follow RIP into the function)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Tips Continued

:::

<!-- element style="font-size: 24px"-->
- Debugging ACCESS_VIOLATION: 
	- This error means you
		- Tried to read memory you are not allowed to read
		- Tried to write to memory your are not allowed to write to 
		- Tied to execute memory you are not allowed to execute
- For the PE loader, you either 
	- Messed up the memory protections 
	- Have invalud function pointers in your IAT
	- Did not perform relocations properly 
	- *Other PE stuff (TLS callbacks)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Relocations 

:::

<!-- element style="font-size: 24px"-->
- Recall that the  ImageBase is the 
preferred
 base address of the PE once it is mapped into memory 
- If we were able to give the PE its 
preferred
 address, then we are done! Pass execution off the the entry point.
- If not, we have more work to do. 
- If the PE has acknowledge the existence of ASLR, we can map it into a different location. If not, panic. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with Absolute Addresses 

:::

<!-- element style="font-size: 24px"-->
- Our PE, while aware of ASLR, might still references addresses that are absolute 
addresses
- In this case, we need to find all of them, calculate their 
offset
 from the 
preferred
 address, and patch them 
- The PE file format makes this easy for us with a structure called the relocation table 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### IMAGE_BASE_RELOCATION
:::

::: left
<!-- element style="font-size: 24px"-->
- The VirtualAddress is a relative Virtual address, where we can relocate a block
- The SizeOfBlock is...well the size of the block 
- typedef
struct
_IMAGE_BASE_RELOCATION
- { DWORD     VirtualAddress;
-   DWORD     SizeOfBlock;
- } IMAGE_BASE_RELOCATION, 
PIMAGE_BASE_RELOCATION;

:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_61_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Relocations

:::

<!-- element style="font-size: 24px"-->
- If the Base Address of the allocated memory matches the 
preferred
 base address of the PE, there is nothing to be done!
- Else, we might need to patch some values. 
- We can parse the relocation table from the option headers  inside of the Data Directory
- We can also compute the “delta” in base addresses by taking the 
preferred
 base address and subtracting it from the mapped address.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Base Relocation

:::

<!-- element style="font-size: 24px"-->
- All memory addresses in the code and data sections are stored relative to the address defined by ImageBase in the OptionalHeader.
-  If the PE can't be loaded at its 
preferred
 memory address, the references must reflect this!
-  The PE stores informations about all these references in the base relocation table inside of the Data Directory 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Relocation

:::

<!-- element style="font-size: 24px"-->
- Each entry has (
SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / 2 entries where each entry is a word. 
- The first 4 bits define the type of relocation
-  the lower 12 bits define the offset relative to the VirtualAddress.
- typedef
struct
_IMAGE_BASE_RELOCATION
- DWORD
VirtualAddress
- DWORD
SizeOfBlock
- IMAGE_BASE_RELOCATION

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### It’s just a switch case

:::

<!-- element style="font-size: 24px"-->
- IMAGE_REL_BASED_ABSOLUTE : nothing to be done
- IMAGE_REL_BASED_HIGHLOW: Add the delta between the preferred base address and the
 allocated memory block to the 32 bits found at the offset.
- IMAGE_REL_BASED_DIR64: Same as above, but addresses are 64 bit.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### TLS Callbacks

:::

<!-- element style="font-size: 24px"-->
- I am just going to give you this one. 
- If you want to use multiple threads, you need to run TLS callbacks that prepare Thread Local Storage. Run this right before passing off execution
- void
HandleTLSCallbacks
void*
 lpImageBase,  
IMAGE_NT_HEADERS
 ntHeaders){
- ntHeaders
OptionalHeader
DataDirectory
IMAGE_DIRECTORY_ENTRY_TLS
Size
- PIMAGE_TLS_DIRECTORY
tls
PIMAGE_TLS_DIRECTORY
)( (
UINT_PTR
)lpImageBase 
ntHeaders
OptionalHeader
DataDirectory
IMAGE_DIRECTORY_ENTRY_TLS
VirtualAddress
- PIMAGE_TLS_CALLBACK
callback
PIMAGE_TLS_CALLBACK
tls
AddressOfCallBacks
- while
callback
- wprintf
L"[+] TLS callback at 
%p\n
, (
void
callback
- callback
LPVOID
) lpImageBase, 
DLL_PROCESS_ATTACH
NULL
- callback
- else
- wprintf
L"No Tls Callbacks!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Packers/Crypters

:::

<!-- element style="font-size: 24px"-->
- Yara rules will help us identify static content in PEs. 
- We can no longer fully rely on them to detect the malware
- Since we can run a PE from memory, we can embed a compressed, and encrypted PE inside of another PE
- We can, however, use it to detect the stub that unpacks the malware
- Usually though, we want to unpack the malware to identify not just the packer but also the final payload 
- This also has implications in how First/second stage payloads work


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### UnPacking Malware

:::

<!-- element style="font-size: 24px"-->
- Let’s assume for now that the unpacked payload is  a .exe  PE. 
- Most stubs that unpack malware need to do the following
- Recover the raw PE Bytes (decompress, decrypt...etc)
- Allocate memory, some of which needs to be executable 
- Copy the PE into memory
- Resolve Import Address Table 
- Handle Relocations 
- TLS callbacks
- Pass execution to the entry point


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Unpacking: Useful Breakpoints

:::

<!-- element style="font-size: 24px"-->
- As always, look at the imports. There might, however, might not be any!
- If we can catch the loader/packer before it passes off execution, we can simply dump the PE from memory 
	- Note that the PE we dump might be memory mapped, in which case we will need to perform the opposite of what our loader does!
- Set a Breakpoint at VirtualAlloc(Ex), or other functions used to allocate memory (HeapAlloc, NtAllocateVirtualMemory...etc)
	-  Run until Return. The value in RAX will be the base address of the allocate memory 
	- Follow this address in dump and keep an eye on this until you see the sections copied into memory 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Matryoshka Dolls
:::

::: left
<!-- element style="font-size: 24px"-->
- Malware authors will routinely Compose Packers 
- This can get very 
annoying
, very fast. 
- You can actually run the same packer multiple times. 
- For example, we can UPX pack our loader to load a UPX packed exe. 
- First,  we need to unpack the real loader, then we unpack the packed payload, then we can dump the actual payload 


:::

::: right
![[0x0c_b6b4ef3d71bb2a6d_slide_70_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Building your own Packer

:::

<!-- element style="font-size: 24px"-->
- Compile a stub to unpack your code that decrypts, and decompresses data 
embedded
 in the PE. An example of this could be a resource file 
- Python
 pefile makes interacting with PE resources easy 
- This way, you can use python to compress and encrypt your payload, and you can embed the result as a resource in a fixed place.
- The primary purpose of a packer is two fold:
- 1) Hash Busting: old signatures no longer work on the packed malware. You can  (and should!) write yara rules for the stub-- but it is very easy to also hash bust the stub!
- 2) 
Frustrating
 the reverse engineer. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Automation

:::

<!-- element style="font-size: 24px"-->
- Scripting a debugger : set breakpoints at common functions found in Packers and scan memory for the magic MZ 
- Unpack.me: unpacking sandbox. Sadly for you all, it is 32bit only >:)
- PE-Sieve: incredible tool by Hasherezade that checks for injected PEs/Shellcode in a process 
- Writing a static unpacker for a specific packer you see a lot can take time, but depending on the circumstances could also be worth it!

