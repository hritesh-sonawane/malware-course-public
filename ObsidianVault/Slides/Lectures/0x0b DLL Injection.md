---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Lecture 0x0b: 

:::
 DLL Injection


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Quick Review

:::

<!-- element style="font-size: 24px"-->
- Static Linking
- Dynamic Linking: Implicit 
- Dynamic Linking: Explicit 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Static Linking 
:::

::: left
<!-- element style="font-size: 22px"-->
- Statically linking against a library embeds the library inside of the PE
- This is inefficient with space, but can solve many portability problems with code. 
- The main reason to statically link a library is if you are unsure if it will be available on the host machine
- This bloats the side of the code, which may or may not be an issue.


:::

::: right
![[0x0b_0d4950aeda6c75d5_slide_4_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Linking: Implicit 

:::

<!-- element style="font-size: 24px"-->
- Implicit Linking is declaring the required imports inside of the PE
- The PE loader will then resolve these imports before execution is passed to the main thread
- If any of the DLLs cannot be found, the PE loader aborts and the process exits with an error. 
- Most legitimate applications use implicit linking, and  will ship with required DLLs packaged together with the application. These DLLs are then loaded at runtime. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports 

:::

<!-- element style="font-size: 24px"-->
- When a DLL is loaded by a process, it is not guaranteed to be placed in the same place in memory, nor is it guaranteed to be placed in the same 
relative
 location 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- To handle variability in load location,  the programer can can declare  all imports in the 
Import Address Table 
(IAT)
- This shifts the work to the PE loader to resolve all the imports.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- The IAT is effectively a collection of key value pairs, where the key is the name of an imported function, and the value is the address of  a small function that jumps to the location of the real function. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Resolving Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- When resolving imports, the PE loader will load all required DLLs, identify the address of the loaded DLL, and patch the IAT with the correct address of the requested function

:::

::: right
![[0x0b_0d4950aeda6c75d5_slide_9_image.png|700]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- The application code simply calls the function referenced in the IAT, which is simply a 
trampoline 
 to the real code.
- I.e., it is a static location relative to the PE’s base address that application code can reference
	- I.e., it is simply an unconditional jump to the memory mapped location of the target function. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Visual: IAT
:::

![[0x0b_0d4950aeda6c75d5_slide_11_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Loading: Explicit 

:::

<!-- element style="font-size: 24px"-->
- The programer explicitly calls LoadLibrary, and has the proper function prototypes inside of their code. 
- The legitimate reason to do this, is to allow the execution of the program to continue even if a DLL does not exist.
- If an import for an implicitly loaded DLL is missing, the program stops. 
- The application using  an explicitly loaded DLL can choose how to handle a missing DLL. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with Relative Addresses

:::

<!-- element style="font-size: 20px"-->
- A relative address is an address that is defined as a particular offset from a 
base address 
(the start of the PE’s image in memory)
- When the application is loaded into memory, same as the DLLs referenced in the IAT, its location might not align with the preferred location 
- In this case, the PE loader needs to modify the Base Location to handle relative locations. 
- This is especially important when exploitation mitigations such as ASLR are enabled, as the PE in this case should (probabilistically) never be loaded in the preferred address. 
- Applications that have only relative addresses are called Position independent. Generating Position Independent Code (PIC) is handled by the compiler, and can be enabled with -fPIC for GCC. This means you will see no unconditional jumps in application code, and instead will only see relative Jumps 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with Absolute Addresses 

:::

<!-- element style="font-size: 24px"-->
- An absolute address is a reference to a static location. Think JMP \<addr\> 
- If this address references a specific spot in memory, this could be tricky. 
- The base relocation table handles absolute addresses by creating a table of pointers to absolute addresses.  
- If the process is not loaded into its preferred address, the PE loader will modify all the absolute addresses to work with the new base address.
- We generally don’t have to worry about this in our class, as all code will be PIC 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DLL Injection

:::

<!-- element style="font-size: 24px"-->
- Forcing a remote process to load a library (DLL)
- The DLL upon being loaded executes whatever code is contained in its attach process code. 
- There are a lot of reasons to do this,  but general it is used for intercepting function calls, interacting with remote processes and hiding code in a remote process 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example one: Anti Malware 

:::

<!-- element style="font-size: 24px"-->
- Many anti-malware executables have all the hallmarks of malware themselves!  
- An AV might inject a DLL into every process that a user spawns. It can then use this DLL to intercept commands to WinAPI functions to detect suspicious sequences of  Function calls 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example 2: Cheat Engines

:::

<!-- element style="font-size: 24px"-->
- Running code in the context of a remote process gives unfettered access to resources used by the target process 
- This can be used to monitor application behavior, modify data, and inject functionality. 
- For example, the attach function in the injected DLL can modify values in memory associated with  player’s health bar. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example 3: Malware and Hooking

:::

<!-- element style="font-size: 24px"-->
- Imagine a user running Google Chrome logging into a website
- If malware injects a malicious DLL into a chrome instance, it can read it’s process memory, modify functions, and steal data 
- For example, if the chrome function that sends an HTTP request is known, the DLL can patch references to that function with a small trampoline to code controlled by the malware 
- The malicious code can then inspect, and modify the arguments and forward them along. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### How?
:::


![[0x0b_0d4950aeda6c75d5_slide_19_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Inject a DLL

:::

<!-- element style="font-size: 24px"-->
- Get the PID of the remote process we want to inject into
- Get the **FULL** path to the DLL on disk
- Open a handle to the remote process with the proper permissions 
- Politely  ask the remote process to call LoadLibrary

 
 OK but how?  


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Process Injection

:::

<!-- element style="font-size: 24px"-->
-   Forcing a remote process to execute code.
- Usually, this involves copying shellcode into a remote process 
-  If we have a shellcode that calls `LoadLibraryA` this would load any DLL we want into the remote process
... OK but how?  

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Process Injection: Key incredients
:::
<!-- element style="font-size: 24px"-->
### Most process injection requires the injector to 

1.  Allocate Read/Write/Executable memory in a remote processes’ address space    
2.  Copy the contents of th code into the remote buffer 
3.  Pass execution to the remote buffer


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Allocating Memory
:::
<!-- element style="font-size: 24px"-->
```c++

LPVOID VirtualAllocEx(
  [in]           HANDLE hProcess,
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
);
```
The only difference between `VirtualAlloc` and `VirtualAllocEx` is we can now pass a handle to a process. When the function is called, the allocated memory will live in the remote process!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Copying Data
:::
<!-- element style="font-size: 24px"-->
We can’t  use memcpy, RtlMoveMemory, or something similar. We need to ask the kernel nicely to copy data from our Virtual Address space to the remote processes virtual Address space 
```c++
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```

Note that we need a pointer to  the start of our code, and the size of it!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Passing execution
:::
<!-- element style="font-size: 24px"-->
-   This is where you can extra get creative. The usual way of passing execution is to invoke CreateRemoteThread (as we did with DLL injection) 
-   Or you could use the native API call RtlCreateUserThread
-   A great talk from Black Hat lists multiple techniques for Process Injection
-   [https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Shellcode Injection: Basic
:::
<!-- element style="font-size: 24px"-->
DEMO: `\xcc\xcc\xcc\xcc\xcc`

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Shellcode Injection: MSF
:::
<!-- element style="font-size: 24px"-->
- Metasploit is an exploitation and Malware framework targeting various OSes
- It has support for several shellcode payloads. One of which, is `LoadLibraryA`

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Inject a DLL (Usual way)

:::

<!-- element style="font-size: 24px"-->
- Get the PID of the remote process we want to inject into
- Get the FULL path to the DLL on disk
- Open a handle to the remote process with the proper permissions 
- Get the address of LoadLibraryA in kernel32.dll in our process
- Allocate a buffer in the remote process 
- Copy the path of the DLL to the remote process
- Force the remote process to execute LoadLibraryA

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Inject a DLL (Usual way)

:::

<!-- element style="font-size: 20px"-->
- Get the PID of the remote process we want to inject into
	- Fork & run OR pass as an argument 
- Get the FULL path to the DLL on disk
	- Hardcode it
- Open a handle to the remote process with the proper permissions 
	- OpenProcess(...)
- Get the address of LoadLibraryA in kernel32.dll in our process
	- This will be the same addr in the remote process! (Why?)
- Allocate a buffer in the remote process 
	- VirtualAllocEx(...)
- Copy the path of the DLL to the remote process
	-  WriteProcessMemory
- Force the remote process to execute LoadLibraryA
	- CreateRemoteThread(...)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Execution dependent: CreateRemoteThread

:::

```c++
HANDLE CreateRemoteThread(
  [in]  HANDLE                 hProcess,
  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  [in]  SIZE_T                 dwStackSize,
  [in]  LPTHREAD_START_ROUTINE lpStartAddress,
  [in]  LPVOID                 lpParameter,
  [in]  DWORD                  dwCreationFlags,
  [out] LPDWORD                lpThreadId
);
```

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### LPTHREAD_START_ROUTINE

:::

<!-- element style="font-size: 24px"-->
- `LPTHREAD_START_ROUTINE lpStartAddress` → function pointer!
- `LPVOID lpParameter` → pointer to start of arguments 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Passing Args to a remote process

:::

<!-- element style="font-size: 24px"-->
- Open a handle to the target Process with OpenProcess
- Allocate a  memory in the remote process with VirtualAllocEx
- Copy the required arguments (the full path to our DLL) into the remote buffer
- At this point, the thread arguments are in the remote process. We simply need to create a remote thread 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling a function in the remote process

:::

<!-- element style="font-size: 24px"-->
- We need to know the sart Virtual Address of the function in the remote processes’ 
address
 space!
- For functions in Kernelbase, kernel32 and ntdll, these will be set randomly on boot, but will be the same from process to process!
- For the simple case, we need only calculate the address of kernel32.dll$LoadLibrayA
- And set the arguments to the full path to our dll


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling a function in the remote process

:::

<!-- element style="font-size: 24px"-->
- The code:

```
(LPTHREAD_START_ROUTINE) GetProcAddress()
GetModuleHandleA("kernel32"), "LoadLibraryA")
```
- The above code gets  the VA of `kernel32.dll!LoadLibraryA` at runtime and casts it to an `LPTHREAD_START_ROUTINE` 
- Use `CreateRemoteThread` with the arguments set to the contents of the remote buffer containing our !

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### End Result

:::

<!-- element style="font-size: 24px"-->
- The remote process creates a new thread who’s code consists of a single call to LoadLibraryA, and whatever code is present in 
DLL_PROCESS_ATTACH
- We will talk more next week about how malware can use this to  “hook” important functions 

---
<!-- slide template="[[Title Slide]]" -->
 ## Dll Injection: Summary
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DLL injection Summary
:::

::: left
Politely
 asking a 
remote
 process to load a  DLL that exists on disk. 


:::

::: right
![[0x0b_0d4950aeda6c75d5_slide_29_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Limitations of the previous setup

:::

<!-- element style="font-size: 24px"-->
Limitations of our previous setup:
- 1) The DLL needs to exist on disk!
- 2) Calling LoadLibraryA creates an image load callback. 
- 3) Doing anything complex (i.e more than running say MessageBoxA) in `DLL_PROCESS_ATTATCH` is going to break stuff. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Limitations of the previous setup

:::

<!-- element style="font-size: 24px"-->
- Doing 
anything complex (i.e more than running say `MessageBoxA`) in `DLL_PROCESS_ATTATCH` is going to break stuff. 
- More generally, doing anything complex in DllMain is inadvisable as it has a high chance of deadlocking the process and either crashing or making it unresponsive 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dll Injection ++

:::

<!-- element style="font-size: 24px"-->
- Instead of forcing a remote process to just call to LoadLibraryA, we can also invoke an exported function in a remote process!
- This allows us to execute more complex payloads
- The processes for this is going to come in handy for when we implement a more advanced version of this 
technique

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps Involved 

:::

<!-- element style="font-size: 24px"-->
- Inject our DLL into the remote process (Same steps as last time)
- Wait for the loading thread to terminate, and get the address of the injected DLL’s base Address
- Calculate the relative virtual address the target exported function 
- Add that offset to the base address of the injected DLL in the remote address 
- Create a thread whos entry point is the remote address of the exported function


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calculating  Offset of the exported function

:::

<!-- element style="font-size: 24px"-->
- Option 1: 
- Calculate it offline 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calculating  Offset of the exported function

:::

<!-- element style="font-size: 24px"-->
- Option 2: 
- Call LoadLibraryA to get a handle to the module. 
- This handle is actually a pointer to memory! In particular, for a 64 bit machine, under the hood this is an unsigned 64 bit integer
- Recall that memory grows downward from lower order addresses to higher order addresses 
- To compute the offset, simple take the address of the exported function and subtract the base address


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calculating  Offset of the exported function

:::

<!-- element style="font-size: 24px"-->
- Option 3: 
- Calculate the offset of the exported function based on the un-mapped dll. (I.e., RVA to File Offset)
- We will revist this when we talk about RDI


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How do we get the addr of the exported func?

:::

<!-- element style="font-size: 24px"-->
- GetProcAddress
(...)


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Computing the Offset
:::


![[0x0b_0d4950aeda6c75d5_slide_37_image.png]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling our exported function

:::

<!-- element style="font-size: 24px"-->
- Once we have the offset of our exported function from DLL, we can compute the address of the exported function inside of the remote process by adding the offset to the Base address!
- But how do we get the base address of the DLL in the remote process?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Method 1

:::

<!-- element style="font-size: 24px"-->
- We can enumerate loaded DLLs in a remote process, and find ours. 
- This is a little tedious. 



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Alternative:

:::

<!-- element style="font-size: 24px"-->
- Write a small 
bootstrap shellcode that reads the base address of Kernel32.dll, and parses GetProcAddress, and Load Library. 
- The shellcode loads our library, and finds its offset
- Finally, the shellcode invokes the exported function 
- Developing the shellcode required to do this is beyond the scope of the class, but it is **possible** that Ch0nky Bear might use this technique...hint hint nudge nudge :) 


---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### 
:::

![[0x0b_0d4950aeda6c75d5_slide_42_image.png]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Some Details

:::

<!-- element style="font-size: 24px"-->
- The Injected DLL performs more complicated actions than just 
popping
message box
- The payload loads a resource from the DLL, in this case two WAV files, and 
plays them!
- Let’s look at some common gotchas


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Getting a Handle to our DLL from our DLL

:::

<!-- element style="font-size: 24px"-->
- This is a parameter in DLL Main!
- The way to handle this is to set a global variable to the handle
- This way we can 
reference
 it inside of our function 
- For example, LoadResource 
requires
 a handle to the executable image to parse the resource from! We would pass the global variable set to the loaded DLL’s handle as the param
