---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Lecture 0x0b: 

:::

DLL Injection


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Quick Review

:::

<!-- element style="font-size: 24px"-->
- Static Linking
- Dynamic Linking: Implicit 
- Dynamic Linking: Explicit 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Static Linking 
:::

::: left
<!-- element style="font-size: 20px"-->
- Statically linking against a library embeds the library inside of the PE
- This is inefficient with space, but can solve many portability problems with code. 
- The main reason to statically link a library is if you are unsure if it will be available on the host machine
- This bloats the side of the code, which may or may not be an issue.


:::

::: right
![[0x08_slide_4_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Linking: Implicit 

:::

<!-- element style="font-size: 24px"-->
- Implicit Linking is declaring the required imports inside of the PE
- The PE loader will then resolve these imports before execution is passed to the main thread
- If any of the DLLs cannot be found, the PE loader aborts and the process exits with an error. 
- Most legitimate applications use implicit linking, and  will ship with required DLLs packaged together with the application. These DLLs are then loaded at runtime. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports 

:::

<!-- element style="font-size: 24px"-->
- When a DLL is loaded by a process, it is not guaranteed to be placed in the same place in memory, nor is it guaranteed to be placed in the same 
relative
 location 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- To handle variability in load location,  the programer can can declare  all imports in the 
Import Address Table 
(IAT)
- This shifts the work to the PE loader to resolve all the imports.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- The IAT is effectively a collection of key value pairs, where the key is the name of an imported function, and the value is the address of  a small function that jumps to the location of the real function. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Resolving Imports
:::

::: left
<!-- element style="font-size: 24px"-->
- When resolving imports, the PE loader will load all required DLLs, identify the address of the loaded DLL, and patch the IAT with the correct address of the requested function

:::

::: right
![[0x08_slide_9_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Resolving Imports

:::

<!-- element style="font-size: 24px"-->
- The application code simply calls the function referenced in the IAT, which is simply a 
trampoline 
 to the real code.
- I.e., it is a static location relative to the PE’s base address that application code can reference
	- I.e., it is simply an unconditional jump to the memory mapped location of the target function. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
 #### Visual: IAT
:::


![[0x08_slide_11_image.png]]




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dynamic Loading: Explicit 

:::

<!-- element style="font-size: 24px"-->
- The programer explicitly calls LoadLibrary, and has the proper function prototypes inside of their code. 
- The legitimate reason to do this, is to allow the execution of the program to continue even if a DLL does not exist.
- If an import for an implicitly loaded DLL is missing, the program stops. 
- The application using  an explicitly loaded DLL can choose how to handle a missing DLL. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with Relative Addresses

:::

<!-- element style="font-size: 24px"-->
- A relative address is an address that is defined as a particular offset from a 
base address 
(the start of the PE’s image in memory)
- When the application is loaded into memory, same as the DLLs referenced in the IAT, its location might not align with the preferred location 
- In this case, the PE loader needs to modify the Base Location to handle relative locations. 
- This is especially important when exploitation mitigations such as ASLR are enabled, as the PE in this case should (probabilistically) never be loaded in the preferred address. 
- Applications that have only relative addresses are called Position independent. Generating Position Independent Code (PIC) is handled by the compiler, and can be enabled with -fPIC for GCC. This means you will see no unconditional jumps in application code, and instead will only see relative Jumps 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dealing with Absolute Addresses 

:::

<!-- element style="font-size: 24px"-->
- An absolute address is a reference to a static location. Think JMP <addr> 
- If this address references a specific spot in memory, this could be tricky. 
- The base relocation table handles absolute addresses by creating a table of pointers to absolute addresses.  
- If the process is not loaded into its preferred address, the PE loader will modify all the absolute addresses to work with the new base address.
- We generally don’t have to worry about this in our class, as all code will be PIC 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### DLL Injection

:::

<!-- element style="font-size: 24px"-->
- Forcing a remote process to load a library (DLL)
- The DLL upon being loaded executes whatever code is contained in its attach process code. 
- There are a lot of reasons to do this,  but general it is used for intercepting function calls, interacting with remote processes and hiding code in a remote process 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example one: Anti Malware 

:::

<!-- element style="font-size: 24px"-->
- Many anti-malware executables have all the hallmarks of malware themselves!  
- An AV might inject a DLL into every process that a user spawns. It can then use this DLL to intercept commands to WinAPI functions to detect suspicious sequences of  Function calls 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example 2: Cheat Engines

:::

<!-- element style="font-size: 24px"-->
- Running code in the context of a remote process gives unfettered access to resources used by the target process 
- This can be used to monitor application behavior, modify data, and inject functionality. 
- For example, the attach function in the injected DLL can modify values in memory associated with  player’s health bar. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example 3: Malware and Hooking

:::

<!-- element style="font-size: 24px"-->
- Imagine a user running Google Chrome logging into a website
- If malware injects a malicious DLL into a chrome instance, it can read it’s process memory, modify functions, and steal data 
- For example, if the chrome function that sends an HTTP request is known, the DLL can patch references to that function with a small trampoline to code controlled by the malware 
- The malicious code can then inspect, and modify the arguments and forward them along. 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### How?






:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x08_slide_19_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Inject a DLL

:::

<!-- element style="font-size: 24px"-->
- Get the PID of the remote process we want to inject into
- Get the **FULL** path to the DLL on disk
- Open a handle to the remote process with the proper permissions 
- Copy the path of the DLL to the remote Process 
- Politely 
ask the remote process to call LoadLibrary
- OK but how?  


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps to Inject a DLL (Usual way)

:::

<!-- element style="font-size: 24px"-->
- Get the PID of the remote process we want to inject into
	- Fork & run OR pass as an argument 
- Get the FULL path to the DLL on disk
	- Hardcode it
- Open a handle to the remote process with the proper permissions 
	- OpenProcess(...)
- Get the address of LoadLibraryA in kernel32.dll in our process
	- This will be the same addr in the remote process! (Why?)
- Allocate a buffer in the remote process 
	- VirtualAllocEx(...)
- Copy the path of the DLL to the remote process
	-  WriteProcessMemory
- Force the remote process to execute LoadLibraryA
	- CreateRemoteThread(...)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Execution dependent: CreateRemoteThread

:::

<!-- element style="font-size: 24px"-->
- HANDLE
CreateRemoteThread
- ]  HANDLE                 hProcess,
-  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
-  [in]  SIZE_T                 dwStackSize,
-  [in]  LPTHREAD_START_ROUTINE lpStartAddress,
-  [in]  LPVOID                 lpParameter,
-  [in]  DWORD                  dwCreationFlags,
-  [out] LPDWORD                lpThreadId
- 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### LPTHREAD_START_ROUTINE

:::

<!-- element style="font-size: 24px"-->
- LPTHREAD_START_ROUTINE lpStartAddress → function pointer!
- LPVOID lpParameter → pointer to start of arguments 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Getting the Arguments into the remote process

:::

<!-- element style="font-size: 24px"-->
- Open a handle to the target Process with OpenProcess
- Allocate a page of memory in the remote process with VirtualAllocEx
- Copy the required arguments (the full path to our DLL) into the remote buffer
- At this point, the thread arguments are in the remote process. We simply need to cre
ate a remote thread 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling a function in the remote process

:::

<!-- element style="font-size: 24px"-->
- We need to know the sart Virtual Address of the function in the remote processes’ 
address
 space!
- For functions in Kernelbase, kernel32 and ntdll, these will be set randomly on boot, but will be the same from process to process!
- For the simple case, we need only calculate the address of kernel32.dll$LoadLibrayA


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling a function in the remote process

:::

<!-- element style="font-size: 24px"-->
- The code:
	- LPTHREAD_START_ROUTINE
GetProcAddress
GetModuleHandleA
"kernel32"
), 
"LoadLibraryA"
- The above code creates calculates the address of kernel32.dll$LoadLibraryA at runtime and casts it to an LPTHREAD_START_ROUTINE 
- Use CreateRemoteThread with the thread arguments set to the contents of the remote buffer containing our DLL!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### End Result

:::

<!-- element style="font-size: 24px"-->
- The remote process creates a new thread who’s code consists of a single call to LoadLibraryA, and whatever code is present in 
DLL_PROCESS_ATTACH
- We will talk more next week about how malware can use this to  “hook” important functions 

---
<!-- slide template="[[Title Slide]]" -->
 ## Dll Injection: Summary
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### DLL injection Summary
:::

::: left
<!-- element style="font-size: 24px"-->
- Politely
 asking a 
remote
 process to load a  DLL that exists on disk. 


:::

::: right
![[0x08_slide_29_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Limitations of the previous setup

:::

<!-- element style="font-size: 24px"-->
- Limitations of our previous setup:
1) The DLL needs to exist on disk!
- 2) Calling LoadLibraryA creates an image load callback. 
- 3) Doing anything complex (i.e more than running say MessageBoxA) in DLL_PROCESS_ATTATCH is going to break stuff. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Limitations of the previous setup

:::

<!-- element style="font-size: 24px"-->
- Doing 
anything complex (i.e more than running say MessageBoxA) in DLL_PROCESS_ATTATCH is going to break stuff. 
- More generally, doing anything complex in DllMain is inadvisable as it has a high chance of deadlocking the process and either crashing or making it unresponsive 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Dll Injection ++

:::

<!-- element style="font-size: 24px"-->
- Instead of forcing a remote process to just call to LoadLibraryA, we can also invoke an exported function in a remote process!
- This allows us to execute more complex payloads
- The processes for this is going to come in handy for when we implement a more advanced version of this 
technique

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Steps Involved 

:::

<!-- element style="font-size: 24px"-->
- Inject our DLL into the remote process (Same steps as last time)
- Wait for the loading thread to terminate, and get the address of the injected DLL’s base Address
- Calculate the relative virtual address the target exported function 
- Add that offset to the base address of the injected DLL in the remote address 
- Create a thread whos entry point is the remote address of the exported function


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calculating the Offset of the exported function

:::

<!-- element style="font-size: 24px"-->
- Option 1: 
- Calculate it offline 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calculating the Offset of the exported function

:::

<!-- element style="font-size: 24px"-->
- Option 2: 
- Call LoadLibraryA to get a handle to the module. 
- This handle is actually a pointer to memory! In particular, for a 64 bit machine, under the hood this is an unsigned 64 bit integer
- Recall that memory grows downward from lower order addresses to higher order addresses 
- To compute the offset, simple take the address of the exported function and subtract the base address


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How do we get the addr of the exported func?

:::

<!-- element style="font-size: 24px"-->
- GetProcAddress
(...)


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Computing the Offset
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x08_slide_37_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling our exported function

:::

<!-- element style="font-size: 24px"-->
- Once we have the offset of our exported function from DLL, we can compute the address of the exported function inside of the remote process by adding the offset to the Base address!
- But how do we get the base address of the DLL in the remote process?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Method 1

:::

<!-- element style="font-size: 24px"-->
- We can enumerate loaded DLLs in a remote process, and find ours. 
- This is a little tedious. 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Method 2

:::

<!-- element style="font-size: 24px"-->
- Because we injected our DLL via CreateRemoteThread, the return value of the LP_THREAD_START_ROUTINE will be stored in the exitstatus!
- That is, if we wait for the loading to finish, we can read the HMODULE (the base address of the library in the remote process) from the exit status via 
- For more on this, see https://stackoverflow.com/questions/7100441/how-can-you-get-the-return-value-of-a-windows-thread


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Alternative:

:::

<!-- element style="font-size: 24px"-->
- Write a small 
bootstrap shellcode that reads the base address of Kernel32.dll, and parses GetProcAddress, and Load Library. 
- The shellcode loads our library, and finds its offset
- Finally, the shellcode invokes the exported function 
- Developing the shellcode required to do this is beyond the scope of the class, but it is possible that Ch0nky Racoon might use this technique...hint hint nudge nudge :) 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x08_slide_42_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Some Details

:::

<!-- element style="font-size: 24px"-->
- The Injected DLL performs more complicated actions than just 
popping
message box
- The payload loads a resource from the DLL, in this case two WAV files, and 
plays them!
- Let’s look at some common gotchas


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Getting a Handle to our DLL from our DLL

:::

<!-- element style="font-size: 24px"-->
- This is a parameter in DLL Main!
- The way to handle this is to set a global variable to the handle
- This way we can 
reference
 it inside of our function 
- For example, LoadResource 
requires
 a handle to the executable image to parse the resource from! We would pass the global variable set to the loaded DLL’s handle as the param

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Taking it One step Further

:::

<!-- element style="font-size: 24px"-->
- A current opsec failure of the current approach is the DLL is required to be on disk. LoadLibrary doesn’t work with raw bytes. 
- A few years ago, someone had the bright idea of reverse engineering LoadLibrary, and figuring out 
exactly
 how the Image loader works
- They then implemented their own version of it, LoadLibraryR, that doesn’t require the DLL to be on disk! 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reflective DLL injection

:::

<!-- element style="font-size: 24px"-->
- Originally (publicly) published  by S
tephen Fewer 
- Allows for the injecting of special special DLLs that have a special exported function
- Any DLL imaginanable can be compiled to have this special function, and in effect allows for loading of DLLs from memory without ever touching disk 
- The 
process
 of loading a DLL from memory by calling this “special” exported function is called Reflective DLL injection
- We call this special exported function the “Reflective Loader”


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reflective DLL Injection

:::

<!-- element style="font-size: 24px"-->
- Copy the Bytes of the DLL into the remote Process
- Pass execution to the 
Reflective
 Loader via CreateRemoteThread (or a small bootstrap Shellcode)
- The reflective loader Does a bunch of magic.
- Note this technique can be extended to PE injection

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### The Reflective Loader

:::

<!-- element style="font-size: 24px"-->
- Parse PE headers
- Find the base Address of kernel32.dll, and find LoadLibraryA, 
GetProcAddress
, and VirtualAlloc
- Copy the 
sections
 and headers into a newly 
allocated
 region of memory 
- Perform base 
relocations
, resolve imports 
- Pass execution back  (either the shellcode, or the thread just exits)

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What can you do with RDI?

:::

<!-- element style="font-size: 24px"-->
- We can download payloads 
entirely
 in memory, and 
execute
 them without touching disk 
- Executables that can’t defeat static indicators can instead store the bytes in an encrypted format, and load it into memory at runtime 
- You can inject into benign processes (explorer.exe, svchost...etc) 
- This make detecting the payload from just looking at the 
task manager
 difficult
- Packing

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Packing

:::

<!-- element style="font-size: 24px"-->
- YARA rules are incredibly effective at detecting static content 
- AVs catch countless threats by  observing static content 
- To combat this, many malware authors will “Pack” their malware to prevent those static signatures from being visible before run time. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Indications that something is packed 
:::

::: left
<!-- element style="font-size: 24px"-->
- Non-standard sections (Eg UPX)
- The number of imports is small. 
	- Note the exe could just be explicitly resolving imports. 
- Sections with high entropy 


:::

::: right
![[0x08_slide_51_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Packers:

:::

<!-- element style="font-size: 24px"-->
- Consist of packed data, and an execution stub
- The stub is used to unpack the packed data, resolve imports, and pass execution to the true entry point 
- Many packers (sometimes referred to as crypters) will combine compression, obfuscation, injection, and encryption to slow down the reverse engineer 
- Some can use Virtualization to make reversing very difficult.
	-  Thankfully, this usually isn’t the case as de-virtualization is a major pain.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Execution

:::

<!-- element style="font-size: 24px"-->
- Most packers execute code  by
- Allocating memory (either local or remote)
- Decrypting/
deobfuscating
 the executable image bytes.
- Copying the raw bytes of the executable image into that memory (this is where we want to catch it!)
- Injecting the bytes (either a DLL, PE (exe), raw shellcode or 
other
 exotic formats) into either a local or remote process
- The flow of execution is somehow redirected to the bytes (possibly after performing relocations, 
dependency
 resolution...etc)


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Next time

:::

<!-- element style="font-size: 24px"-->
- Reflective DLL injection: the details of the reflective Loader
- Packing, and unpacking
- Detecting Reflectively Loaded DLLs

