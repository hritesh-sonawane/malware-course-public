---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x0e
Symmetric Cryptography


---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### Cryptography
:::
<!-- element style="font-size: 24px"-->
- Oxford definition: "The art of writing  and solving codes"
- Our definition: A collection of  primitives used to "protect" data from an "adversary"
- What exactly is menat by "Protect" and "Adversary" is very, very technical
---
<!-- slide template="[[Split Vertical]]" -->
::: title 
#### Cryptography
:::

::: left
<!-- element style="font-size: 24px"-->
- While cryptocurrency is built using  Cryptography, we will not be discussing this at all. 
- Please don't ask me about what coints to invest in. 

:::
::: right
![[0x0e-dan-boneh.png]]
:::


---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### Cryptography in this class (Protective)
:::
<left>

<!-- element style="font-size: 24px"-->
- Securing C2 Communications 
- Protecting data at rest 
- Authenticating  implants to C2
- Authenticating Operators to C2


---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### Cryptography in this class (Offensive)
:::
<left>

<!-- element style="font-size: 24px"-->
- Abusing the DPAPI
- Identifying cryptography in software
- Extracting of "protected" data in software
- Attacking cryptography use in malware 
- Understanding ransomware

---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### Cryptographic Primitives
:::
<!-- element style="font-size: 28px"-->
- Symmetric Ciphers (stream ciphers, block ciphers)
- Message Authentication Codes
- Cryptographic Hash Functions
- Asymmetric Ciphers
- Key Agreements
---
<!-- slide template="[[Base Slide]]" -->
::: title 
#### Cryptographic Protocols 
:::
<!-- element style="font-size: 28px"-->
- Authenticated Encryption with Associated Data ( AEAD) 
- Hybrid Crypto schemes 
- Noise Protocol 
- Proof of Work
- (Basics of ) Public Key Infrastructure 
 


---
<!-- slide template="[[Title Slide]]" -->
 ## Disclaimer
 
<left> 
This is not a rigorous introduction introduction to cryptography, it is a crash course. I will be taking a *lot* of shortcuts-- some of which may result in the use of *imprecise* language. 

Leo, if you're watching this, please don't hate me :smile:




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Basic Definitions 

:::

<!-- element style="font-size: 24px"-->
- For now, we will assume a setup where two entities, Alice and Bob, are communicating  each other... 
- Plaintext: the message/data being transited  
- Encryption: A reversible algorithm designed to garble data in an attempt to provide *privacy*. 
- Ciphertext: the result of encrypting a plaintext using an encryption algorithm 
- Secret key: a  *secret* value used in encryption and decryption. knowledge of the key and the algorithm allows *anyone* to encrypt and decrypt data.
- Computationally bounded adversary: an adversary with limited resources (time, space, computing power...etc)



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Security and Communication 
:::

::: left
<!-- element style="font-size: 24px"-->
- What does it mean for a method of communication to be “secure”? 
- Well, secure from *what*?
- Usually, it is from an entity that is trying to eavesdrop. 
:::

::: right
![[0x0e_f82fb5be418697e9_slide_7_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Communicating over an “Unsafe” Channel 

:::

<!-- element style="font-size: 24px"-->
- When talking about security, it is essential to to describe the type of Adversary you are secure from!
- Over the past few decades, Cryptography has evolved into an offshoot of Complexity Theory. 
- Security definitions are defined in terms of the adversary that cannot invalidate some property given their abilities with an reasonable chance of success.
- Usually, this involves a *security game* where repeated trials result in only a *negligible* advantage


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Symmetric Cryptography (simple case) 

:::

<!-- element style="font-size: 24px"-->
- Cryptographic protocols between two parties that have agreed on a shared secret. 
- The Algorithm used is public
- The only secret data is the  secret key.



---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Scenario 1: Eve
:::

::: left
<!-- element style="font-size: 24px"-->
- Consider two Entities “Alice” and “Bob” that wish to communicate over a reliable communication channel. 
- Suppose that an adversary Eve is able to install a *tap* in their channel, and can eavesdrop on all messages exchanged
- This is a reasonable setup: *why?*


:::

::: right
![[0x0e_f82fb5be418697e9_slide_10_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Informal Goal: Secure Against Eve

:::

<!-- element style="font-size: 24px"-->
- When sending data across a communication channel, an adversary who is able to position themselves as a tap in the network should not be able to learn anything “meaningful” about the contents of the data they see.
-  In particular, even if they were able to view the encryption of some polynomial number of messages, they should not be able to distinguish encrypted data from random noise  (i.e. I.I.D. Bernoulli(p=.5) )


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Informal Goal: Secure Against Eve (Game)

:::

<!-- element style="font-size: 24px"-->
- Eve is able to see the encryption of some polynomial number of messages
- Then, Eve selects two challenge plaintexts $(p_0 , p_1)$ and we flip a coin
- If it is heads, we send $Enc(p_0)$
- if it is tails, we send   $Enc(p_1)$
- If Eve can distinguish between the two with non-negligible advantage, then Eve wins the game, and our protocol does not protect against Eve


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Informal Goal: Secure Against Eve

:::

<!-- element style="font-size: 24px"-->
- Cryptographic Primitive to Enable this: CPA Secure  Cipher 
- See  Chosen Plaintext  Attack (CPA) security for a more rigorous treatment of this.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Informal Goal: Secure Against Eve

:::

<!-- element style="font-size: 24px"-->
- Question: Based on the previous security Game, are CPA secure encryption algorithms deterministic? I.e. if I encrypt the same message twice, I get the same output. 
- No! Otherwise, Eve would just select challenge messages that they have seen before, and win <!-- element class="fragment" -->

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Limitations of Eve
:::

::: left
<!-- element style="font-size: 22px"-->
- Eve is only able to sniff the contents of messages. 
- In the event that Eve is discovered as Tap by one party, say Bob, they are unable to prevent the other prevent Bob from warning Alice
- In the context of an implant and a C2 server, it might not matter that Eve can see our communication if we can achieve a particular goal unhindered  


:::

::: right
<iframe width="1180" height="664" src="https://www.youtube.com/embed/2jo3i0-_X-k" title="I Think Some People are Eavesdropping!" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Scenario 2: Mallory
:::

::: left
<!-- element style="font-size: 24px"-->
- Consider now an adversary that has all the powers of Eve and one addition:
- Mallory is able to modify messages in transit!
- This could involve dropping, modifying and/or replaying  messages

:::

::: right
![[0x0e_f82fb5be418697e9_slide_14_image.png|500]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Secure against Mallory 

:::

<!-- element style="font-size: 24px"-->
- When Mallory is able to position themselves as an active MITM, Alice and Bob should be able to
- authenticate themselves to each other
- detect when a message has been modified 
- detect when a message has been replayed 
- detect when a message been forged
- detect when a message been dropped  

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Secure against Mallory 

:::

<!-- element style="font-size: 24px"-->
- Security Game (CPA). The adversary selects messages $p_i$ and gets to see their tags $t_i$ before trying to produce a forgery. If they succeed with non-negligible advantage, then they win and the scheme is not secure against Mallory.
- Cryptographic primitive to enable this: Message Authentication Codes  (MACs)
- For a more rigorous treatment, see existential unforgeability 
- https://cseweb.ucsd.edu/~mihir/papers/gb.pdf
- Note this on its own does not prevent replay attacks. How could we achieve this?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Message Authentication Codes

:::

<!-- element style="font-size: 24px"-->
- Symmetric protocol to detect  data corruption/tampering
- Simplest example of this is HMAC (Hash MAC)
- HMAC: Fun fact, invented by a BU professor: Ran Canetti



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Summary:

:::

<!-- element style="font-size: 24px"-->
- Privacy: nobody can read the contents of your messages 
- Integrity: if anyone modifies/spoofs a message in transit, you will detect it
- We want cryptosystems that give us these properties 
- (More generally, we want stronger notions of secure against ** but this is sufficient for a crash course.)
- do not, under any circumstances, roll your own crypto. You will, and this is true, shoot yourself in the foot. 
- Seriously, don't. 



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Perfect Secrecy (informal) 

:::

<!-- element style="font-size: 24px"-->
- No amount of computational power can give you odds better than just guessing 
- Only the One-time pad has this property 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Security: Computationally Bounded Adversary

:::

<!-- element style="font-size: 24px"-->
- The “advantage” an adversary gets in predicting your plaintext after seeing it’s ciphertext is exponentially small (negligible) 
- A more rigorous treatment of this topic is beyond the scope of our class, but the idea here is we want to create an algorithm that without knowledge of the secret key, the adversary has a negligible change of recovering the plaintext.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Caesar Cipher

:::

<!-- element style="font-size: 24px"-->
- Start with an alphabet 
- Messages are composed of characters contained in the alphabet 
- A secret key k is a random value between 0 and len(alphabet)-1
- The ciphertext is created by shifting each character of the alphabet k positions clockwise  after assigning every character in the alphabet with a position on a clock. 
- The plaintext is recovered by shifting each character counter clockwise k positions 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Security of the Caesar Cipher

:::

<!-- element style="font-size: 24px"-->
- When the length of the message > 1: it is not great 
- We can check all possible keys if the size of the alphabet is reasonable 
- I.e., it is vulnerable to a brute force search  


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### One Time Pad

:::

<!-- element style="font-size: 24px"-->
- Message: bytes of length n
- Key: random bytes of length n
- Encrypt: compute ciphertext= message xor key 
- Decrypt: compute plaintext = ciphertext xor key 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Limitations of the One Time Pad

:::

<!-- element style="font-size: 24px"-->
- As the name suggests, you should only use the random byte stream once 
- Encrypting  large volumes of data  requires a large pool of entropy
- Ciphertexts are “malleable” 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Note: 

:::

<!-- element style="font-size: 24px"-->
- Remember, any data that you leave in a binary can be recovered by a skilled reverse engineer
- In other words, you should assume that they get leaked!


=
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stream Ciphers

:::

<!-- element style="font-size: 24px"-->
- A cryptographic algorithm that acts a lot like the One time pad, with the exception that the stream of pseudo-random bytes are generated by using a cryptographically secure Pseudo Random Number Generator (csPRNG) 
- Stream Ciphers are Synchronous 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Common Stream Ciphers

:::

<!-- element style="font-size: 24px"-->
- RC4
- Salsa20
- ChaCha20

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Block Ciphers

:::

<!-- element style="font-size: 24px"-->
- Encrypt data in chunks called blocks 
- If the size of the data is not a multiple of  the block size, it needs to be “padded”
- If the size of the data is larger than the block size, the algorithm needs a “mode of operation”
- Those two requirements have created a pretty massive headache for cryptographers and are hard to get right.


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Common Block Ciphers
:::

::: left
<!-- element style="font-size: 24px"-->
- Rijndael/AES
- Blowfish
- TEA/xTEA
- SIMON/SPECK (Sus but not for the reasons you think :-)
- DES  3DES
- RC5 (Sus :-)

:::

::: right
![[0x0e_f82fb5be418697e9_slide_31_image.png|500]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Common Mistakes 
:::

::: left
<!-- element style="font-size: 20px"-->
- Messing up the padding. There are a lot of ways to do this.
- Using ECB mode for a block cipher 
- Reusing nonces in CBC mode 
- Using weak algorithms (rot ciphers, substitution ciphers)
- Inadequate authentication to the server 
- Inadequate server authentication to the client 
- Failure to use MACs
- Using weak hash functions 


:::

::: right
![[0x0e_f82fb5be418697e9_slide_32_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Practical Attacks on Crypto

:::

<!-- element style="font-size: 24px"-->
- This class will focus on attacking crypto used by malware from the perspective of a reverse engineer. 
- In particular, we will look at how we can recover keys, replay messages, inject our own data, and  decrypt traffic. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Recovering the Key From the Malware 

:::

<!-- element style="font-size: 24px"-->
- Statically: hard(ish?)
- Dynamically: usually easy. Find the function that encrypts/decrypts and just set a breakpoint. 
- How do you find that function? 
- Set breakpoints on common WinCrypt API functions
- Look for known constants
- trace your way backwards in the call stack  after network communication.
- Read the code, and SUFFER




---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Security Vs Obscurity 

:::

<!-- element style="font-size: 24px"-->
- As we will see, it is usually easy to identify implementation of common block ciphers and stream ciphers. 
- In the context of extracting configuration data from an implant, is it better to use a robust, easy to identify cryptographic primitive, or an ad hoc weaker primitive? 
- When is security through obscurity enough?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Threat model: Malicious OS

:::

<!-- element style="font-size: 24px"-->
- From the perspective of the malware author, when leveraging cryptography we must assume that the OS the implant is executing on is malicious.
- I.e., it has the ability to periodically scan memory
- It could have some visibility into library functions/syscalls 
- On corporate devices, this is especially true as there is likely a program running whos' whole purpose is to detect the presence of your code
- You're implant could also be running in a sandbox!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Implant Security: Networking

:::

<!-- element style="font-size: 24px"-->
- Lets consider how we could establish a secure connection to a C2 server.
- We share the secret key with the implant, and embed it inside of the code
- This key is used to establish a secure connection to the c2 by leveraging the primitives we discussed earlier (Ciphers + MACs)
- How is this vulnerable?

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Implant Security: Configuration

:::

<!-- element style="font-size: 24px"-->
- Suppose there are strings/data that we need to use for our implant to function properly
- A common technique for defense evasion is to encrypt/obfuscate these static values, and then at runtime, decrypt/deobfuscate them
- This can be achieved via a program that can protect the data at compile time, embed it in the compiled program, and include code to recover the data
- How is this defeated?


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Identifying Common Crypto

:::

<!-- element style="font-size: 24px"-->
- Constants
- Common Round Functions 
- Example, using a ghidra plugin to identify sha256 in crackme 4.
- https://github.com/TorgoTorgo/ghidra-findcrypt


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Integrity Vs Privacy

:::

<!-- element style="font-size: 24px"-->
- Privacy: nobody can read what your messages are
- Integrity: if anyone modifies your data in transit, you will detect it



---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What should you use for C2 Sessions?

:::

<!-- element style="font-size: 24px"-->
- Generally Believed to be secure 
- AES-GCM
- CHACHA20-Poly1305
- Remember, all of this is moot if they simple pull the symmetric key out of your binary or dump it from memory. You should assume your session keys will eventually get leaked the same way you should plan for your implant eventually getting caught!

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Solid Libraries

:::

<!-- element style="font-size: 24px"-->
- OpenSSL, LibreSSL, python Cryptography, Rust Crypto, LibSodium, Monocypher, NACL
- For your implant, I would recommend using a combination if Windows Crypto API functions along with a statically linked cryptography library. OpenSSL is very large, as is LibreSSL. An experimental library that is targeted for embedded devices is LibHydrogen and WolfCrypt are good options.
- I have also personally made use of 
https://github.com/jedisct1/libhydrogen/tree/v0
 (old branch)
- Note that the cryptography you use is something that can be used to identify you 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What is missing?

:::

<!-- element style="font-size: 24px"-->
- Problem: If your key gets leaked, then all previous communications are also easily decrypted.
- Problem: How do we get keys distributed? 
- Problem: How do we authenticate to the server? How does the server authenticate to us?


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Opsec Considerations 
:::

::: left
<!-- element style="font-size: 24px"-->
- Using custom crypto can identify you
- Your implant is executing on a malicious OS. This makes privacy very difficult. 
- Your goal should be to blind the defenders until you have achieved your goal 
- Cryptography can hide your data, but it is harder to hide the fact that you are using cryptography! 


:::

::: right
![[0x0e_f82fb5be418697e9_slide_48_image.png|300]]


:::










---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Ransomware
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x0e_f82fb5be418697e9_slide_17_image.png|300]]


:::






---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Ransomware 
:::

::: left
<!-- element style="font-size: 24px"-->
- Malware that encrypts  sensitive data, and 
extorts   victims for the decryption key
- If done properly, the data is at the mercy of the ransomware operator  

:::

::: right
![[0x0e_f82fb5be418697e9_slide_3_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How does ransomware work?

:::

<!-- element style="font-size: 24px"-->
- Enumerate files
- Filter files that are 
sensitive
/not critical to OS function
- Encrypt the files 
- Make your 
presence
 known (Leave a 
ransom note
- Extract payment, and provide decryptor 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Example: RC4
:::

::: left
<!-- element style="font-size: 24px"-->
- RC4 is very likely broken. 
- It should not be used in any production environment and was removed from TLS. So why are we talking about it?
- Well, RC4 is an incredibly simple cipher to implement, and a fan favorite of malware authors. 


:::

::: right
![[0x0e_f82fb5be418697e9_slide_35_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### RC4
:::

::: left
<!-- element style="font-size: 24px"-->
- Key scheduling algorithm
- Stream generation
- - https://github.com/kbsec/misc_crypto/blob/master/rc4/rc4.py

:::

::: right
![[0x0e_f82fb5be418697e9_slide_36_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### RC4: Rivest Cipher 4

:::

<!-- element style="font-size: 24px"-->
- Stream cipher commonly  used by malware authors due to its ease of implementation
	- Cryptography poses an engineering challenge, as any code you write client side needs to have a counterpart server side. Implementing RC4 is trivial in any language! 
- Two components:
	-  Key-Scheduling Algorithm (KSA)
	- Pseudo Random Generation Algorithm 
- PRNG that generates random bytes from an initial seed (the key)
- Algorithm is synchronous, meaning Client and server need to maintain state information. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### KSA

:::

<!-- element style="font-size: 24px"-->
- Initialize an array S of 256 bytes where each  byte is set to its index in the array 
- We then use the key to create a random permutation of 256 bytes
- That is, we can view S as defining a function, where the input is the index in the array, and the output is the value stored in the array 
- That is, initially, S[i] = i for all i=0,...,255, S[input] = output is the identity function
- Using the Key, we randomly swap values inside of the S array 
- S is usually called an “S-box”


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Generating Psuedo random bytes 

:::

<!-- element style="font-size: 24px"-->
- Pull data from the Sbox according to the algorithm and update.


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Looking at RC4 in Assembly 

:::

<!-- element style="font-size: 24px"-->
- Let’s spend some time implementing it!
- We can compile the end result with the -g flag to generate a PDB
- Load it into Ghidra and see if we can identify the relevant portions 


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo