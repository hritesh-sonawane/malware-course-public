---
theme: night
height: 540
margin: 0
maxScale: 4
slideNumber: true
---

<!-- slide bg="[[Green Logo.svg]]" background-size="auto" -->

---


<!-- slide template="[[Split Vertical]]" -->
::: title
#### CS-4973
:::
::: left
![[Green Logo.svg | 400]] <!-- element style="object-fit: cover" -->

:::
::: right
<!-- element style="font-size: 32px;align:center" -->
Introduction to Malware, Threat Hunting & Offensive Capabilities Development
:::


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### CS-501 

:::

<!-- element style="font-size: 24px"-->
- Introduction to Malware, Threat Hunting & Offensive Capabilities Development


---
<!-- slide template="[[Title Slide]]" -->
 ## Lecture 0x04: 
C, C++ and Static Analysis 
---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Agenda for This Lecture
:::

::: left
<!-- element style="font-size: 24px"-->
- C/C++ on Windows
- Ghidra 
- WinApi
- GCC, Mingw, Zig/clang
- Assembly, x86/x64
- Calling Conventions

:::

::: right
![[0x04_slide_3_image.jpg|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Overview 

:::

<!-- element style="font-size: 24px"-->
- C++ is a statically typed, compiled language that is very similar to C
- A large portion of malware you will encounter is written in C/C++
- C/C++ has no Garbage collector:
	- This Forces the developer to manage their own memory
- While it is general purpose, we will use it as a systems programing language
- C++ has many 
different
 versions, many different compilers and tools to help with debugging 
- Reflection isn’t supported by default in C++
	- There is no such thing as type() like there is in python

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Concepts you need to know for this class

:::

<!-- element style="font-size: 24px"-->
- Memory 
management
 with C/C++
- Pointer Arithmetic 
- Basic C types 
- - Note these are 
prerequisites


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Difference between C/C++

:::

<!-- element style="font-size: 24px"-->
- C++ is a (near) superclass of C. The standard library has extra features that can make using C++ easier and safer. This can come with a performance penalty.
- C++ has support for classes and structs. C only supports structs.
- C++ supports encapsulation 
- C++ has namespaces 
- While you can directly call malloc/HeapAlloc in C++, it has new/delete and “smart” pointers that simplify 
managing
 memory 
	- You are welcome to use C as opposed to C++


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Modern C++	

:::

<!-- element style="font-size: 24px"-->
- Supports functional programing in addition to OOP,
auto/decltype,Variadic templates and more!
- We will only cover a small portion of these features but you are encouraged to use the standard library to its fullest.
- C++ is considerably more user friendly than it was when it was first released and with the release of C++20, programining 


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### C/C++ and Memory Safety
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x04_slide_8_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### C/C++ 
:::

::: left
<!-- element style="font-size: 24px"-->
- It is hard to write safe C
- I don’t care what anyone says. Writing C is hard.
- - Shout out to @jgeigerm who I stole this joke from


:::

::: right
![[0x04_slide_9_image.png|300]]
![[0x04_slide_9_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### C/C++ 
:::

::: left
<!-- element style="font-size: 24px"-->
- Simple mistakes like using int* instead of size_t* can lead to serious vulns.
- Why is this dangerous?
- Modern C++ has tools to  make managing memory safer/easier
	- Spoiler! It is still hard


:::

::: right
![[0x04_slide_10_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Writing Safe C Code
:::

::: left
<!-- element style="font-size: 24px"-->
- It is really hard to do. It can be even more difficult to identify bugs once they are introduced. 
- Some tools make identifying heap issues at runtime easier: Eg 
https://github.com/google/sanitizers/wiki/AddressSanitizerWindowsPort
 but this is mostly for fuzz testing and is too much of an overhead at runtime

:::

::: right
![[0x04_slide_11_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### X86-64 Assembly Crash Course
:::

::: left
<!-- element style="font-size: 24px"-->
- Assembly language is machine specific code that is executed directly by a processor
- X64 (amd64) is an extension of 32bit x86
- It contains 16 general purpose registers: 
RAX
RBX
RCX
RDX
RBP
RSI
RDI
and
 RSP, R8
R15
- Note: You are expected to be familiar with x86 assembly


:::

::: right
![[0x04_slide_51_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Registers by Name

:::

<!-- element style="font-size: 24px"-->
- RAX - register a extended. Usually return register for integers
- RBX - register b extended 
- RCX - register c extended 
- RDX - register d extended
- RBP - register base pointer (start of stack) (32bit: EBP)
- RSP - register stack pointer (current location in stack, growing downwards) 
- RSI - register source index (source for data copies) 
- RDI - register destination index (destination for data copies)
- RIP - Instruction Pointer (pointer to the next instruction)
- Replace the “R” with an “E” and you get the analogous instruction in x86.


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Refresher: Types
:::

::: left
<!-- element style="font-size: 24px"-->
- Byte: 8 bits
- Word: 2 bytes (16 bits)
- Double Word (Dword) 32 bits
- Quadword: 64 bits
- Double Quadword: 128 bits
- Intel stores bytes as “Little Endian”


:::

::: right
![[0x04_slide_53_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Declaration Mapping
---
<!-- slide template="[[Title Slide]]" -->
 ## Common 
Instructions
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Calling Conventions

:::

<!-- element style="font-size: 24px"-->
- Calling conventions are 
conventions 
used to invoke functions. This includes how to pass arguments to the function, and how to get returned objects.
- Functions defined do not need to abide by this convention
	- In fact, weird calling conventions is a common obfuscation technique 
- The Windows API has a standardized calling convention for most of its functions. 
	- Note that WinAPI expands to 
__stdcall

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Windows x64 Calling Convention: Simple case

:::

<!-- element style="font-size: 24px"-->
- RCX, RDX, R8, R9 are used for integer, and pointer arguments in that order from left to right
- Additional arguments are pushed to the stack (left to right)
- The return value (integer/pointer) is stored in RAX if it is 64 bits or less 
- Return values > 64 bits (structs, classes) will have stack space allocated by the 
caller
	- This case is a bit more complicated and will be covered when we start reverse engineering C++ objects 
-  RAX, RCX, RDX, R8, R9, R10, and R11 are 
volatile
- Src: https://software.intel.com/content/www/us/en/develop/articles/introduction-to-x64-assembly.html


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How are we learning x64 in this class?

:::

<!-- element style="font-size: 24px"-->
- The best way to get more comfortable reading assembly is to keep reading assembly. 
- You do not have to write (much) assembly in this course, but you will have to read it. 
- The decompiler offered by Ghidra will often make mistakes, and incorrectly reflect what the program is doing. 
- The disassembled  program is (usually) the ground truth

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Looking at Assembly:
:::

::: left
<!-- element style="font-size: 24px"-->
- We will use Intel Flavor assembly syntax. Why? Because it is better. 
- Why is it better? Because that happens to be the convention I learned.
- Examples:
- Basic MessageBox
- MessageBox Thread
- Crackme (Relevant to homework)
- Troll.exe 
- Src: https://www.reddit.com/r/ProgrammerHumor/comments/56fjm5/att_vs_intel_syntax/


:::

::: right
![[0x04_slide_59_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Ghidra
:::

::: left
<!-- element style="font-size: 24px"-->
- Free and open source reverse engineering framework
- Supports a TON of architectures (SLED is awesome!)
- Decompiler is very decent! Comparable to IDA pro

:::

::: right
![[0x04_slide_60_image.png|300]]


:::

---
<!-- slide template="[[Title Slide]]" -->
 ## Using Ghidra to Look at our code
---
<!-- slide template="[[Title Slide]]" -->
 ## Using X64dbg to look at our code
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Example: MessageBox

:::

<!-- element style="font-size: 24px"-->
- global _main
- extern MessageBoxA 
; Import external symbols from user32.dll
- extern ExitProcess ; 
Import external symbols from kernel32.dll
- SECTION .data
-     message0 
 "Hello world!", 
; null terminator
-     message1 
 "I am a message!", 
- SECTION .text
- sub
rsp
- xor
rcx
rcx
; pass NULL for handle
- mov
rdx
, message0
- mov
, message1
- xor
- call
 MessageBoxA
- call
 ExitProcess
- - 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack: what is it good for?

:::

<!-- element style="font-size: 24px"-->
- Local variables
- Passing arguments to a function
- Returning values from a  function 
- Function invocation/ABI

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Data structure built on top of our Virtual Address Space that allows us to Push, and pop values from a stack
- Whenever we invoke a function with 
call 
 a new 
stack frame
 is created. We call this the function call stack
- This is a contiguous chunk of memory that acts as a working space for a function’s duration

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Stack Memory

:::

<!-- element style="font-size: 24px"-->
- Stack memory is temporary: once the function returns the memory is reclaimed
- Still error prone but is typically safer and faster than Heap allocations  
- A programer usually does not need to worry about managing stack memory
- We need to know how much is needed at compile time!


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Stack based Footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- Stack overflows
- Referencing reclaimed stack memory 
- careful when copying/referencing strings/raw data
- Note: You cannot return a string from a function safely! 

:::

::: right
![[0x04_slide_67_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Heap Memory
:::

::: left
<!-- element style="font-size: 24px"-->
- Memory that can be allocated/deallocated at runtime
- Used for data whose size is not known at compile time
- Slower than stack 


:::

::: right
![[0x04_slide_68_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Heap Allocation

:::

<!-- element style="font-size: 24px"-->
- Allows for dynamic allocation sizes. 
- Recall we don’t need to know how much memory is needed at compile time
- Heap memory is managed by a heap allocator. 
- The programmer allocates with a call to malloc and frees the memory with a call to free
- If the programer forgets to call free, that memory is now unusable until the process terminates and we have introduced a 
memory leak


---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### C/C++ In a nutshell 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x04_slide_70_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Footguns. So many footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- If you try and free memory that has already been freed, you are going to get undefined behavior and possibly an exploitable bug. 
- This is called a double free


:::

::: right
![[0x04_slide_71_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Footguns. So many footguns 
:::

::: left
<!-- element style="font-size: 24px"-->
- If you try and reference memory that has already been freed, you are going to get undefined behavior and possibly an exploitable bug. 
- This is called a use after free bug


:::

::: right
![[0x04_slide_72_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Dead Squirrels: AKA uninitialized memory 
:::

::: left
<!-- element style="font-size: 24px"-->


:::

::: right
![[0x04_slide_73_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Uninitialized memory

:::

<!-- element style="font-size: 24px"-->
- An uninitialized variable is one that is declared, with no value set
- For example, DWORD x; char x[20];
- Depending on the compiler, the contents of x could be completely random 
- This will lead to unexpected behavior 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Memory Corruption

:::

<!-- element style="font-size: 24px"-->
- Allocating memory on the heap (malloc/new) without freeing it 
- This memory is no longer usable for allocation and from the perspective of the processes is used
- Some compilers/runtimes will detect when allocations have gone out of scope
- You should not rely on this. Anytime you call new/malloc, you should also call delete/free 
- 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Returning Stack Variables 

:::

<!-- element style="font-size: 24px"-->
- If we have a pointer to memory in a stack frame, when we exit the function that memory might no longer be valid
- By accessing it directly after the function it might look OK, but this is incredibly dangerous 
- In particular, the process will reclaim this memory and it will likely be filled with garbage. 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### HW is up!
:::

::: left
<!-- element style="font-size: 24px"-->
- It is Due two weeks from today. You should get started on this ASAP. 
- In this assignment you will get exposed to CrackMes: puzzles used to practice your reverse engineering skills!
- The goal is simple: Find the input that makes the binary print “Cracked!”
- In this assignment you will get comfortable staring at some basic assembly, and finding the main function when a C-runtime is used.
- You don’t have to ever run the binary, but you can to verify your answer!


:::

::: right
![[0x04_slide_77_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Get started soon!
:::

::: left
<!-- element style="font-size: 24px"-->
- If you don’t have previous reverse engineering experience, you probably can’t do this homework the night before it is due!
- Get started ASAP: it is difficult to predict where you will get stuck!
- None of the CrackMes are designed to trick you per say, but they might not be straight forward!


:::

::: right
![[0x04_slide_78_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### CrackMes 2021: A Savage Hypocrisy 
:::

::: left
<!-- element style="font-size: 24px"-->
- Let’s look at the CrackMe’s I released for the first iteration of the class.
- We will only cover the first 3, but you are welcome to check out the binaries/solutions on the previous course github

:::

::: right
![[0x04_slide_79_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 0
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended difficulty: trivial (so long as you know how to find the main entry point!)
- Run strings on the binary. 
- Find main
- See that it is directly comparing your input to a static string

:::

::: right
![[0x04_slide_80_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 1:
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Easy
- The binary checks if the length of the input is 26, and if it starts with a C

:::

::: right
![[0x04_slide_81_image.png|300]]
![[0x04_slide_81_image.png|300]]


:::

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (Learn from my mistakes. )
:::

::: left
<!-- element style="font-size: 24px"-->
- Intended Difficulty: Moderate
- Question to answer: WTF is happening inside of that do-while loop?

:::

::: right
![[0x04_slide_82_image.png|300]]


:::

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Crackme 2 (Again, learn from my mistakes!)

:::

<!-- element style="font-size: 24px"-->
- A stack variable is declared, with values inside of the ASCII range (HINT)
- We iterate through values in argv[1]
- Copy that character into a buffer
- Copy the char from the stack var into a buffer
- Checks to see if the the input char + 5 is the same as the stack variable
- If not, Fail. If yes, continue
- Once we are done checking all the characters in the stack string with no errors, Success 

---
<!-- slide template="[[Split Vertical]]" -->
::: title
 #### Crackme 2 (...Oops)
:::

::: left
<!-- element style="font-size: 24px"-->
- Moral of the story: Don’t leave your work until the night before it is due.
- You will make careless mistakes, and if you’re like me and don’t have tenure it could be a bad look!
- Also…maybe don’t use aggressive Debug statements. 
- OR git commit messages:
https://www.youtube.com/watch?v=KjYBh7rq0-Y


:::

::: right
![[0x04_slide_84_image.png|300]]


:::

