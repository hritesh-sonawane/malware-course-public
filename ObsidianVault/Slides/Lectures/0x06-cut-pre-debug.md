

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Program vs Process

:::

<!-- element style="font-size: 24px"-->
- A program is a static collection of instructions.
- A process is a container for a set of resources used when executing **an instance** of a program 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Processes

:::

<!-- element style="font-size: 24px"-->
- Basic container for resoruces required to run a process. For example, threads, private virtual address space, handles, ...etc 
- Nothing is executed outside of the context of a process.
- You don’t “run a processes”
- You run threads which are managed by a processes

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### What Makes a Process

:::

<!-- element style="font-size: 24px"-->
- private 
 virtual address space 
- A program 
mapped
 to the virtual address space
- A collection of open 
handles to objects 
- A Process ID
- \>=1 thread 
- *Security/token information. 


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Process Creation	

:::

<!-- element style="font-size: 24px"-->
- Complicated. We will simplify it for now 
- Kernel opens the image (executable file) and verifies it is the correct format
- The kernel creates a new process kernel object and a thread kernel object
- The kernel maps the image to an address space, as well as ntdll.dll 
	- Note this gets mapped to just about every type of process
- The creator process notifies Windows subsystem process (Csrss.exe) that a new process and thread have been created
- From the kernel’s perspective, the process is created at this point 
- Some magic happens, imports are resolved and after all the required DLLs are loaded, we reach the entry point and the program starts 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Kernel Objects

:::

<!-- element style="font-size: 24px"-->
- Kernel object (KOs): a single run-time instance of a statically defined object type 
- Object types are system-defined data types. 
- Each object type has its own attributes and functions to interact with it
- For example, an object of type 
process 
is an instance of a process object.
- file 
object is an instance of a file. Note, 
file!= a thing on disk


---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Reminder: Objects and Handles 

:::

<!-- element style="font-size: 24px"-->
- A handle is an abstract reference to an object. This could be an actual pointer to the object, or a reference to a GUID that references an object
- This allows us to abstract away direct management of objects in memory, and instead work with with references. 
This is a security control. If something goes wrong in kernel space, you get a BSOD. 
- APIs are used to interact with system resources, share resources among processes, and protect resources from unauthorized access.

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### How to Create a Process

:::

<!-- element style="font-size: 24px"-->
- Ask the kernel nicely to create one for you! 
- eg, use an API such as `CreateProcess,ShellExecute`
```c++
BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,
  [in, out, optional] LPSTR                 lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
```
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Digging into CreateProcess’ Arguments  

:::

<!-- element style="font-size: 24px"-->

-  https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Basic Information of a Process

:::

<!-- element style="font-size: 24px"-->
- Name: Usually the executable name. This is NOT a unique identifier 
- Process ID (PID): Unique ID of a process. PIDS are reused after a process terminates
- Status: Running, Suspended, Not Responding 
- Username: the user who is running the process. It also includes the primary token that holds the security context for the user
- Session ID: Session number under which the process executes. 
	- Session 0 is for system processes and services. 
	- Session 1 and higher are used for interactive logins.


---
<!-- slide template="[[Title Slide]]" -->
 ## Demo: Creating a Process 
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Processes Vs Threads 

:::

<!-- element style="font-size: 24px"-->
- Processes are (usually) independent, and are containers for threads
	- Non Example: python multiprocessing, Chrome.exe + sandbox
- Threads in the same process share process state, memory and other resources 
- Processes have separate address spaces, and threads in the same process share the same address space 
- Processes can interact with each other via system-provided Inter Process Communication (IPC) mechanisms 
	- Pipes, sockets, files, ...etc
- Threads have per-process shared storage (Thread Local storage: TLS) 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Threads 

:::

<!-- element style="font-size: 24px"-->
- Unit of execution contained within a process 
- I.e., the actual entity that executes code 

---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Threads

:::

<!-- element style="font-size: 24px"-->
- An entity within a process that that actually executes code
- Threads are scheduled 
- Threads have access to the contents of multiple CPU  registers 
- Threads hace private memory for shared objects (Thread Local Storage)
- Threads can have a security context that is different from other threads within a process. 
	- Security is weird with Windows. Like really weird. 
- Users can schedule their own threads via Fibers/ User Mode 
scheduling
	- From the kernel’s perspective, this is only 1 thread executing


---
<!-- slide template="[[Title Slide]]" -->
 #### If each process gets its Virtual Address space, how do we interact with shared objects?
---
<!-- slide template="[[Base Slide]]" -->
::: title
#### Sharing Objects 

:::

<!-- element style="font-size: 24px"-->
- We share objects by sharing 
handles 
to objects
- In order to share a handle, we can either copy a reference to the same handle, or duplicate the handle (this creates a new GUID )

---
