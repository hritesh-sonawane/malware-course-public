<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title></title>
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="plugin/highlight/zenburn.css" />
	<link rel="stylesheet" href="css/layout.css" />
	<link rel="stylesheet" href="plugin/customcontrols/style.css">



    <script defer src="dist/fontawesome/all.min.js"></script>

	<script type="text/javascript">
		var forgetPop = true;
		function onPopState(event) {
			if(forgetPop){
				forgetPop = false;
			} else {
				parent.postMessage(event.target.location.href, "app://obsidian.md");
			}
        }
		window.onpopstate = onPopState;
		window.onmessage = event => {
			if(event.data == "reload"){
				window.document.location.reload();
			}
			forgetPop = true;
		}

		function fitElements(){
			const itemsToFit = document.getElementsByClassName('fitText');
			for (const item in itemsToFit) {
				if (Object.hasOwnProperty.call(itemsToFit, item)) {
					var element = itemsToFit[item];
					fitElement(element,1, 1000);
					element.classList.remove('fitText');
				}
			}
		}

		function fitElement(element, start, end){

			let size = (end + start) / 2;
			element.style.fontSize = `${size}px`;

			if(Math.abs(start - end) < 1){
				while(element.scrollHeight > element.offsetHeight){
					size--;
					element.style.fontSize = `${size}px`;
				}
				return;
			}

			if(element.scrollHeight > element.offsetHeight){
				fitElement(element, start, size);
			} else {
				fitElement(element, size, end);
			}		
		}


		document.onreadystatechange = () => {
			fitElements();
			if (document.readyState === 'complete') {
				if (window.location.href.indexOf("?export") != -1){
					parent.postMessage(event.target.location.href, "app://obsidian.md");
				}
				if (window.location.href.indexOf("print-pdf") != -1){
					let stateCheck = setInterval(() => {
						clearInterval(stateCheck);
						window.print();
					}, 250);
				}
			}
	};


        </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template"><!-- .slide: class="drop" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 700px; width: 960px; min-height: 700px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Malware Development Capstone Project

## Overview
The goal of this capstone project is to develop a fully functional Command and Control (C2) framework, consisting of an implant, a C2 server, and a client. The project will be completed in groups of up to 3 students, and the code must be managed using a private Git repository (GitHub or GitLab) with the course staff's accounts added for evaluation.

## Requirements

### Implant
The implant must target the Windows operating system and satisfy the following requirements:

1. **RPC and C2 Channel**: Communicate with the C2 server using a custom Remote Procedure Call (RPC) framework built on top of an approved C2 channel (e.g., HTTP) and a chosen serialization format (e.g., JSON, TLV, protobuf).

2. **Cryptography**: Implement secure cryptography for session establishment, configuration obfuscation, and encrypted communication with the C2 server.

3. **Situational Awareness**: Gather information about the victim machine, including environment variables, network interfaces, Windows version, user token, computer name, GUID, running processes, and more.

4. **Execution and Injection**: Support the execution of shellcode in local and remote processes, as well as process injection techniques.

5. **File I/O**: Read files from the victim machine and exfiltrate them to the C2 server. Download files from the C2 server and write them to disk on the victim machine.

6. **Persistence**: Implement at least one persistence mechanism to survive system reboots.

7. **Loot**: Programmatically loot information from the victim machine, such as Chrome passwords and cookies.

8. **Defense Evasion**: Employ techniques to evade detection, such as configuration string obfuscation, minimal use of cmd.exe/powershell.exe, and an additional chosen technique (e.g., a custom packer, AMSI bypass, API hashing).

9. **Payload Format**: The implant must be available as a Portable Executable (PE), a Dynamic Linked Library (DLL), and a Reflective DLL.

10. **Modularity**: The implant should be designed with modularity in mind, allowing for easy extension and modification of functionality.

11. **Minimal use of libc**: To reduce the implant's footprint and potential detection, minimize the use of libc functions and opt for direct system calls when possible.

### C2 Server
The C2 server must be able to handle connections from multiple operators and implants, and should include the following components:

1. **Database**: Use a database (e.g., Postgres or MySQL) to store information about implants, commands, jobs, and clients.

2. **Messaging**: Implement a messaging system to notify operators of events such as new implant connections, client connections, and job updates.

3. **RPC and C2 Channel**: Handle incoming connections from implants and clients using the chosen RPC and C2 channel.

### Client
The client must be able to securely connect to the C2 server, send and receive data, and receive updates from the implants. It can be either a terminal or web interface, and must include authentication if it is a web interface.

### Special Feature
Each group must implement an advanced C2 feature of their choosing, such as an advanced implant command, RPC, UI feature, or another approved feature.

### Deliverables

1. **Code**: All code must be submitted via the private Git repository, and must include documentation and comments.

2. **Poster**: Create a poster detailing the features, architecture, OPSEC considerations, and potential use cases of your C2 framework.

3. **Demo**: Deploy and demonstrate your C2 framework, showcasing its functionality, special features, and discussing its MITRE ATT&CK techniques and potential detection methods.

4. **Writeup**: Document your C2 framework in a report or README.md file, including usage instructions, MITRE ATT&CK techniques, OPSEC considerations, and detection rules.

## Helpful Resources
- [Metasploit Payloads](https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter) - Example of a C implant
- [Shad0w](https://github.com/bats3c/shad0w) - A C2 framework built in C and Python
- [SILENTTRINITY](https://github.com/byt3bl33d3r/SILENTTRINITY) - A Python-based C2 framework with a focus on modularity
- [ReflectiveDLLInjection](https://github.com/stephenfewer/ReflectiveDLLInjection) - A library for Reflective DLL injection
- [MemoryModule](https://github.com/fancycode/MemoryModule) - A library for loading DLLs from memory
- [Donut](https://github.com/TheWover/donut) - A tool for converting .NET assemblies to shellcode
- [sRDI](https://github.com/monoxgas/sRDI) - A tool for converting DLLs to shellcode
- [Mimikatz](https://github.com/gentilkiwi/mimikatz) - A popular tool for credential dumping and other post-exploitation tasks

## Evaluation
The capstone project will be evaluated based on the completion of the requirements, the chosen special feature, code quality and organization, and the content and quality of the poster, demo, and writeup. The team with the best C2 framework, as judged by the course staff, will receive a special prize.

## Deadlines
- Milestone 1: Team formation and project roadmap meeting with instructors
- Milestone 2: Completion of the implant's core functionality (RPC, cryptography, situational awareness, execution)
- Milestone 3: Completion of the implant's additional functionality (file I/O, persistence, loot, defense evasion)
- Final Deliverables: Code, poster, demo, and writeup

Please note that late submissions for the writeup may be accepted, but late submissions for the presentation and poster will not be accepted, as attendance at the poster session is mandatory to pass the course.
</div></script></section></div>
    </div>

    <script src="dist/reveal.js"></script>

    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/math/math.js"></script>
	<script src="plugin/mermaid/mermaid.js"></script>
	<script src="plugin/chart/chart.min.js"></script>
	<script src="plugin/chart/plugin.js"></script>
	<script src="plugin/customcontrols/plugin.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

	  function isLight(color) {
		let hex = color.replace('#', '');

		// convert #fff => #ffffff
		if(hex.length == 3){
			hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`;
		}

		const c_r = parseInt(hex.substr(0, 2), 16);
		const c_g = parseInt(hex.substr(2, 2), 16);
		const c_b = parseInt(hex.substr(4, 2), 16);
		const brightness = ((c_r * 299) + (c_g * 587) + (c_b * 114)) / 1000;
		return brightness > 155;
	}

	var bgColor = getComputedStyle(document.documentElement).getPropertyValue('--r-background-color').trim();
	var isLight = isLight(bgColor);

	if(isLight){
		document.body.classList.add('has-light-background');
	} else {
		document.body.classList.add('has-dark-background');
	}

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath.MathJax3,
		  RevealMermaid,
		  RevealChart,
		  RevealCustomControls,
        ],


    	allottedTime: 120 * 1000,

		mathjax3: {
			mathjax: 'plugin/math/mathjax/tex-mml-chtml.js',
		},
		markdown: {
		  gfm: true,
		  mangle: true,
		  pedantic: false,
		  smartLists: false,
		  smartypants: false,
		},

		mermaid: {
			theme: isLight ? 'default' : 'dark',
		},

		customcontrols: {
			controls: [
			]
		},
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"width":960,"height":700,"margin":0.04,"controls":true,"progress":true,"slideNumber":true,"transition":"slide","transitionSpeed":"default"}, queryOptions);
    </script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>

  <!-- created with Advanced Slides -->
</html>
