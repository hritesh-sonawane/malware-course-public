
Start this ASAP. 
## Coding 
In this assignment, you will practice using the windows API. I recocmend reading about C++ containers such as  `std::vector`, `std::string`, C++ classes and the Windows API.  

## Required Reading
If you ask me a question that is answered in the following links, I will shame you just a little bit :-). OK not actually but I will politely direct you to one of  the links. 

- https://www.w3schools.com/cpp/cpp_classes.asp
- https://www.w3schools.com/cpp/cpp_strings.asp
- https://www.geeksforgeeks.org/vector-in-cpp-stl/
- https://www.geeksforgeeks.org/stdstring-class-in-c/
- https://docs.microsoft.com/en-us/windows/win32/winhttp/winhttp-c-c---api-reference (This is a starting point, see if you can find the example code :-) )

### Warmup:  Base64 Encoding/Decoding
In class, we discussed different strategies for encoding and decoding data. One of them is to base64 encode raw  bytes. In this problem, you will leverage Windows API calls to  create a simple Base64 encoder/decoder 

To accomplish this, you should make use of 
- `CryptBinaryToStringA` https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptbinarytostringa (used for encoding)
- `CryptStringToBinaryA` https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptstringtobinaryA(used for decoding )
- In both cases, you should set `dwFlags` to  `CRYPT_STRING_BASE64`

A  recreation of the desired functionality is displayed below in python 
```python 
import sys
import base64 

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} (encode|decode) data ")
        return
    data = sys.argv[2]
    if sys.argv[1] == "decode":
        print(base64.b64decode(data).decode())
    elif sys.argv[1] == "encode":
        print(base64.b64encode(data.encode()).decode())
    else:
        print("Bad args: set to either encode or decode")

if __name__ == "__main__":
    main()
		
```

```bash
$ python test_b64.py encode asdf
YXNkZg==
$ python test_b64.py decode YXNkZg==
asdf

```

### AES-GCM
In this problem, you will  create a simple AES-GCM client in C++ using the Windows next generation Cryptography API.  Directions here will be sparse. You must read the source code in the aes directory, and understand what the program needs to do. 

Ensure that the your code can pass the test as well. 

Reading:
- https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptencrypt


```
malloc/free
new/delete
Vectors/Strings as containers 
Smart Pointers

You may not use LocalAlloc or VirtualAlloc, HeapAlloc ...etc.
```

Write a Client that interacts with the Windows Crypto API to Write an AES-GCM cryptography client. This should support Encryption and Decryption . See the starter code and Makefile for more.



### Basic HTTP Client 
In this section, you are going to implement a basic HTTP client using WinHTTP.  Start by reading the following documentation:
https://docs.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page

Your starter code comes with a few files:
- Makefile: Basic template for building your client 
- Contains some starter code to get you started. 


You must implement an HTTP client that takes 3 positional arguments from the command line:
- A Fully Qualified Domain Name (FQDN)
- The port  (80 for HTTP, 443 for HTTPS)
- The URI of the website 
- either 1 (use HTTPS) or 0 (Use HTTP)


It then makes an HTTP Get request  

An example script of what your code should do is recreated using python below 
```python
import sys
import requests 

def make_request(fqdn, port, uri, use_tls):
    transport = "http" if use_tls == "0" else "https"
    url = f"{transport}://{fqdn}:{port}{uri}"
    print(f"DEBUG: {url}")
    r = requests.get(url )
    if r.status_code == 200:
        print(r.text)
        return 


def main():
    if len(sys.argv) != 5:
        print(f"Example Useage: {sys.argv[0]} google.com 443 / 1")
        return 
    fqdn, port, uri, use_tls = sys.argv[1:]
    print(make_request(fqdn, port, uri, use_tls))

if __name__ == "__main__":
    main()
	
```

```bash
# example usage
# use http
python test_http.py example.com 80 / 0

# use https
python test_http.py example.com 443 / 1
```

To receive full credit, your code must  display the correct text from the response in the console using `std::cout`.  Note that you can use Remnux to test HTTPS as well. 

You may assume that when your code is graded, that the proper command line arguments are provided. I.e., you do not *have to * do any error checking for command line arguments but it is still a good idea to do so :). 

In order to make an HTTP request, you must do the following:
- Initialize a WinHttp Session  `::WinHttpOpen()`
	```c++
	// https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopen
	 WINHTTPAPI HINTERNET WinHttpOpen(
		  LPCWSTR pszAgentW,
		  DWORD   dwAccessType,
		  LPCWSTR pszProxyW,
		  LPCWSTR pszProxyBypassW,
		  DWORD   dwFlags
		);
	 ```
- Configure the HTTP client with `WinHttpConnect`
	```c++
	// https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect
	WINHTTPAPI HINTERNET WinHttpConnect(
		  HINTERNET     hSession,
		  LPCWSTR       pswzServerName,
		  INTERNET_PORT nServerPort,
		  DWORD         dwReserved
		);
	```
- Create an HTTP Request Handle `WinHttpOpenRequest`. Hint: This is the function where you can set a flag to configure the client to use TLS 
	```c++
	//https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopenrequest
	WINHTTPAPI HINTERNET WinHttpOpenRequest(
		  HINTERNET hConnect,
		  LPCWSTR   pwszVerb,
		  LPCWSTR   pwszObjectName,
		  LPCWSTR   pwszVersion,
		  LPCWSTR   pwszReferrer,
		  LPCWSTR   *ppwszAcceptTypes,
		  DWORD     dwFlags
		);
	```
	- For testing, you may also disable certificate verification by setting `WINHTTP_OPTION_SECURITY_FLAGS` with  `WinHttpSetoption` to ` SECURITY_FLAG_IGNORE_UNKNOWN_CA | SECURITY_FLAG_IGNORE_CERT_DATE_INVALID | SECURITY_FLAG_IGNORE_CERT_CN_INVALID | SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE`
- Once you are happy with your request, send it via 
```c++
//hRequest is the handle to your HTTP request returend from ::WinHttpOpenRequest
//Note that in this case, we don't have any extra headers or POST data. Read the arguments for WinHttpSendRequest Carefully, as you will have to add support for sending data on the next homework :-)
::WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA,0,0,0 )
```
- Next, call `WinHttpReceiveResponse`  to get a handle to the response data. 
- Check if there is data available: `WinHttpQueryDataAvailable`
- Iterate over the response and keep calling `WinHttpReadData` until there is no more data to be read. You should accumulate all text data in a std::string buffer  buy having a fixed Char* buffer of say 4096 bytes, that you write to, and append to your buffer. 
- Cleanup all of your handles by calling `WinHttpCloseHandle` on each WinHTTP handle. 
	- You should also have sufficient error checking. I.e, if an error is encountered along the way to sending or receiving the request, you should close all open handle, and terminate the code.  To receive full credit, you must close all handles after either an error, or the HTTP request is finished. 
- Finally, return the result and print it using `std::cout`
- Note that the grading script will use RegEx to verify your code is working. For this reason, you should not print any debugging information for the release build that you submit for grading. Handle this either by using reprocessing macros and a DEBUG  value, or simply comment out all calls to `std::cout` aside from the final one for submission. 
