# Process Execution 
This coding assignment will walk you through the process of spawning a console child processes, and retrieving the output. To do this, we will explore 4 different methods for doing so. 

Before getting started, 
- please read the documentation for for https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
-
For each portion of this homework, you will create a console application that takes two arguments: a process to spawn, and any command line arguments needed by the child processes. You will then redirect the output of the child processes back to the parent processes.

## Guideline
- All of your functions need perform adequate error checking. 
	- I.e. any call to `malloc` should be checked to ensure the result isn't a null pointer (not enough memory probably!)
	- Check if Handles are valid.
	- Check if actions (such as calls to `CreateProcessA` worked)
	- All handles need to be closed eventually
	- All allocated memory needs to be freed eventually 
	- Failure to perform basic error checking, or cleanup will result in significant loss of points :)
	- I have specific tests cases for this
- **You may NOT work in groups** The coding section of this homework is solo. 
	- I reserve the right to quiz you on any work you submit. 

WHen Creating a child prcess, ensure that no new windows is created. 

## Redirect Execution to a file
### Method 1: `>,>>`
Recall that `cmd.exe` and `powershell.exe` both have redirect operators. For example, if you were to execute `whoami >  whoami.txt`, it would execute `whoami.exe`, then redirect the output of this command to the textfile `whoami.txt`. 
Similarly, if we executed `echo "^this is whoiam" >> whoami.txt` the file would look like this:

```powershell
PS C:\Users\User> echo "^This is whoiam" >> whoami.txt
PS C:\Users\User> cat .\whoami.txt
Computer\user
^This is whoiam
```

In this problem, you will take advantage of the redirect operator, and basic File I/O to execute a command,  redirect the output to a  file, then read the contents of the file and print its contents.  Your program  should use the following Win API Functions  
- `CreateProcessA`
- `WaitForSingleObject`
	-  Note that you need to wait for the child processes to terminate before reading the file! Use this function!
- `CreateFileA`
- `GetFileSizeEx` (You may NOT assume all outputs are < 4GBs in size)
- `ReadFile`  or `CreateFileMappingA`

#### Part 1
Implement `BOOL PrintFileContents(char* filename){}`
This function takes as an argument a char pointer assumed to be a valid null terminated c string. The program then creates a file object from the filename, opens it in GENERIC_READ. 
- You should only Create the file object if the file exists on disk 
- You should limit sharing to the file, and only allow other processes to read the file's contents. 
- You should then ensure that the file handle is valid
- Next, get the size of the file using `GetFileSizeEx`
- From there, allocate a buffer to read the file into memory.  
	- Note we need to use *heap memory* for this, as we do not know the size of the buffer we will need at compile time
		- Technically, you could set a Maximum buffer size and read the file in batches. But for this assignment, get some practice using `malloc`/`free` :-) 
	
- Explain in the comments why your buffer is the size you chose
- Ensure that you were able to allocate memory
- Read the contents of the file into the allocated buffer
- Print its contents using `printf` without adding any *additional new lines*  (i.e., `printf("%s\n", var);` vs `printf("%s", var);`)
- you should use debug statements during development, but make sure to strip them before submitting. This will break the auto grader. Please use `debug.h` for printing.

#### Part 2
Use CreateProcessA to spawn a processes and use the redirect operator `>` to direct the output to a file.
- Make sure to spawn the process in such a way that you can get a handle to it! This way, you can pass that handle to `WaitForSingleObject` to ensure the child processes terminates before you read the outfile!
- Hint: set module to NULL, and use `sprintf` to create the full cmdline from program, args, and outfile
- Note that you also won't know the size of the args at compile time! Use heap to allocate a buffer for this. 
- Don't forget to error check!

### Method 2:
In this problem, you will spawn a new console processes, and redirect the output to a file. From there, you will print the contents of the file.

We will accomplish this without using the redirect operator in the command line. You will directly share the handle to an out-file object with the child processes, using handle inheritance.
The flow will look similar to the previous problem,
- Parse arguments
- Create a file object that will act as an outfile for the child processes.
- Modify the relevant values int he arguments for `CreateProcessA` to allow for inheriting of handles. I.e., the child processes spawns with access to handles in the Parent process
- Modify the child processes's  StdOut & StdErr console handle to be the file handle for the out file. 
- Run the child processes and wait for it to terminate
- Perform any needed cleanup
- Read and print the contents of the file. 



*For this problem, you are forbidden from using the redirect operators.* If you use them, you will not receive credit for this problem.  That said, the ultimate result will be the exact same! 

You should reuse the `PrintFile` function from before

## Method 3
Spawn a child processes, that redirects the output to an anonymous pipe. This method will look very similar to Method 2, except instead of using a handle to a file, we will use a handle to an anonymous pipe. Recall that a pipe is a uni-directional object for sending and receiving data-- even between two different processes!
- Pipes exist only in memory, and are *buffered*
- This means we should attempt to read the data sent through the pipe as soon as it becomes available to prevent data loss.
	- In other words, we don't necessarily want to wait until the child processes is terminated!
	- Note that `WaitForSingleObject` supports timeouts, and will return a specific constant if the processes is still running!
Steps:
- Parse the command line arguments
- Ensure that the child processes will inherit handles by setting the correct value in a struct used in `CreateProcessA`
- Next, make a single call to `CreatePipe` and pass as arguments the address of two Handle objects.
- This will create a pipe, and give us an interface to read from the read end of the pipe, and write to the write end of the pipe
- Since we only want the processes to have access to the write end of the pipe, and not the read end, you should use `SetHandleInformation` to ensure that the Read end is *NOT* inherited
- Next, set the handles for StdOut and StdErr to the write end of the pipe
- Run `CreateProcessA` as before
- Now here comes the tricky part: we need to  start reading from the pipe, but if we try to read from a pipe with no data queued, we will get an access violation
- To prevent this, either use exceptions (expensive, and probably still error prone) or `PeekNamedPipe` (recommended) to check if there is any data available. 
- if so keep calling ReadFile()  using a fixed (stack) buffer of 4096 bytes,
	- Note this means you should read at most 4095 bytes at a time, as we need 1 bytes for the null terminator!
- If ReadFile is successful, and you read more than 0 bytes, print the contents like so `printf("%s", buffer);` 
	- I.e., no extra new line 
- You should repeat this processes until the processes finally terminates and you empty the pipe
- In other words, you should have two loops:
	- The outer one is something to the effect of `while my child processes is still alive...`
	- and the inner loop is something to the effect of `while there is data to read from the pipe...`
- Cleanup as needed (Pipe, processes, thread....etc)

