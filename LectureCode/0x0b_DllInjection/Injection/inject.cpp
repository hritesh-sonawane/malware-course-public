#include <windows.h>
#include <iostream>
#include <cstdlib>


// note that for 64bit machine, an address type is unsigned 64 bit integer
// For 32bit, it would be unsigned 32  bit
UINT_PTR CalculateExportedFuncAddr( LPCSTR lpPath, HMODULE hPayloadBase, LPCSTR lpFunctionName ) {
  // Load payload in our own virtual address space
  HMODULE hLoaded = ::LoadLibraryA( lpPath );

  if( hLoaded == NULL ) {
    return 0;
  } else {
      // Calculate the offset 
    auto  lpFunc   = ::GetProcAddress( hLoaded, lpFunctionName );
    UINT_PTR dwOffset = (UINT_PTR)lpFunc - (UINT_PTR)hLoaded;
    std::cout << "Base addr: " << (HMODULE) hPayloadBase << " func Addr: " << (HMODULE)lpFunc << " Offset: " << dwOffset<<std::endl;
    ::FreeLibrary( hLoaded );
    return (UINT_PTR)hPayloadBase + (UINT_PTR) dwOffset;
  }
}




int main(int argc, char** argv){
    if (argc !=  3){
        std::cout << "Usage: " << argv[0] << " pid path_to_dll exportedFunc" << std::endl;
        return 0;
    }
    DWORD pid  = atoi(argv[1]);
    // exported function name
    char funcName[] = "Surprise";

    HMODULE hInjected= NULL;
    // get handle to process we wish to inject in
    HANDLE hProcess = ::OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD,
		FALSE,  pid);

    if (!hProcess){
        std::cout << "Failed to open Process " << pid << ": Error " << ::GetLastError() << std::endl;
        return 0;
    }
    // allocate memory for a call to LoadLibrary()
    void* dllBuffer = ::VirtualAllocEx(
        hProcess, 
        nullptr, 
        1 << 12,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );

    if( !dllBuffer){
        std::cout << "Failed to allocate memory " << ::GetLastError() << std::endl;

        return 0;
    }
    auto argBufSize =  (strlen(argv[2])  + 1) * sizeof(char);
    // write small bootstrap 
    if (!::WriteProcessMemory(hProcess, dllBuffer, argv[2], argBufSize, nullptr)){
        std::cout<< "Failed to write process memory "<< ::GetLastError() << std::endl;
		return 0 ;
    }
    DWORD tid;
	HANDLE hThread = ::CreateRemoteThread(
        hProcess, 
        nullptr, 
        0, 
		(LPTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandleA("kernel32"), "LoadLibraryA"), 
		dllBuffer, // Force the remote function to call Load Library <myModule>
         0, 
         &tid);

    if ( !hThread){
        std::cout << "Failed to create remote thread! " << ::GetLastError() << std::endl;
        return 0;
    }
    
    std::cout << "[+] Created thread " << tid << " successfully!" << std::endl;

	if (WAIT_OBJECT_0 == ::WaitForSingleObject(hThread, 5000)){

		std::cout << "[+] Thread Exited! Time to inject " << std::endl;
        // Get the base Address of the proc in the remote thread
        // this gives us the base address because our thread returns a handle to the module!
        // this is a hack, and a safer way to do this would be to enumerate loaded processes
        // but this is fine for our purposes 
        ::GetExitCodeThread( hThread, ( LPDWORD )&hInjected );

        UINT_PTR addr = CalculateExportedFuncAddr(argv[2], hInjected, funcName);
     HANDLE hThread = CreateRemoteThread( hProcess, NULL, 0,
        (LPTHREAD_START_ROUTINE)addr, NULL, 0, NULL );

        }	
	
	// Cleanup
	::VirtualFreeEx(hProcess, dllBuffer, 0, MEM_RELEASE);
    if(hThread){
        	::CloseHandle(hThread);

    }
    if( hProcess){
	::CloseHandle(hProcess);

    }
    return 0;

}