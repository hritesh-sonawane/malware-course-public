#include <windows.h>
#include <iostream>
#include <cstdlib>
#include <string>


int main(int argc, char** argv){
    if (argc < 3){
        std::cout << "Usage: " << argv[0] << " pid path_to_dll" << std::endl;
        return 0;
    }
    int pid  = std::stoi(argv[1]);
    HANDLE hProcess = ::OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD,
		FALSE,  pid);
    if (!hProcess){
        std::cout << "Failed to open Process " << pid << ": Error " << ::GetLastError() << std::endl;
        return 0;
    }
    // allocate memory for a call to LoadLibrary()
    void* dllBuffer = ::VirtualAllocEx(
        hProcess, 
        nullptr, 
        1 << 12,
        MEM_RESERVE | MEM_COMMIT,
        PAGE_READWRITE
    );

    if( !dllBuffer){
        std::cout << "Failed to allocate memory " << ::GetLastError() << std::endl;

        return 0;
    }
    auto argBufSize =  (strlen(argv[2])  + 1) * sizeof(char);
    // write small bootstrap 
    if (!::WriteProcessMemory(hProcess, dllBuffer, argv[2], argBufSize, nullptr)){
        std::cout<< "Failed to write process memory "<< ::GetLastError() << std::endl;
		return 0 ;
    }
    DWORD tid;
	HANDLE hThread = ::CreateRemoteThread(
        hProcess, 
        nullptr, 
        0, 
		(LPTHREAD_START_ROUTINE)::GetProcAddress(::GetModuleHandleA("kernel32"), "LoadLibraryA"), 
		dllBuffer, // lpthread args : this is creating a callable function pointer LoadLibraryW(<MyLibrary>)
         0, 
         &tid);

    if ( !hThread){
        std::cout << "Failed to create remote thread! " << ::GetLastError() << std::endl;
        return 0;
    }
    
    std::cout << "Created thread " << tid << " successfully!" << std::endl;

	if (WAIT_OBJECT_0 == ::WaitForSingleObject(hThread, 5000)){

		std::cout << "Thread Existed" << std::endl;
        }	
	
	// Cleanup
	::VirtualFreeEx(hProcess, dllBuffer, 0, MEM_RELEASE);

	::CloseHandle(hThread);
	::CloseHandle(hProcess);
    return 0;

}