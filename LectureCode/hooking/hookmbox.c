#include <windows.h>

#include <stdio.h>
typedef int(WINAPI *fnMessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,
                                   UINT uType);

// Helper function to get the Import Directory
PIMAGE_IMPORT_DESCRIPTOR GetImportDirectory(HMODULE hModule) {
  PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule;
  if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
    return NULL;
  }
  PIMAGE_NT_HEADERS ntHeaders =
      (PIMAGE_NT_HEADERS)((BYTE *)dosHeader + dosHeader->e_lfanew);
  DWORD importDirectoryRVA =
      ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
          .VirtualAddress;
  return (PIMAGE_IMPORT_DESCRIPTOR)((BYTE *)hModule + importDirectoryRVA);
}

// Helper function to get the import descriptor for a specific DLL.
PIMAGE_IMPORT_DESCRIPTOR GetImportDescriptor(HMODULE hModule,
                                             LPCSTR lpModuleName) {
  PIMAGE_IMPORT_DESCRIPTOR pImportDesc = GetImportDirectory(hModule);

  while (pImportDesc->Name) {
    LPCSTR moduleName = (LPCSTR)((LPBYTE)hModule + pImportDesc->Name);
    if (_stricmp(moduleName, lpModuleName) == 0) {
      return pImportDesc;
    }
    pImportDesc++;
  }
  return NULL;
}

BOOL IsFunctionIATHooked(LPCSTR lpModuleName, LPCSTR lpFunctionName) {
  HMODULE hModule = GetModuleHandle(NULL); // Handle to the current executable
  HMODULE hImportedModule = GetModuleHandle(lpModuleName);
  if (!hImportedModule) {
    printf("Failed to get handle for module %s.\n", lpModuleName);
    return FALSE;
  }

  FARPROC pRealFunction = GetProcAddress(hImportedModule, lpFunctionName);
  if (!pRealFunction) {
    printf("Failed to get real address for function %s.\n", lpFunctionName);
    return FALSE;
  }

  PIMAGE_IMPORT_DESCRIPTOR pImportDesc =
      GetImportDescriptor(hModule, lpModuleName);
  if (!pImportDesc) {
    printf("Failed to find import descriptor for %s.\n", lpModuleName);
    return FALSE;
  }

  PIMAGE_THUNK_DATA pThunk =
      (PIMAGE_THUNK_DATA)((LPBYTE)hModule + pImportDesc->FirstThunk);
  while (pThunk->u1.Function) {
    FARPROC *ppfn = (FARPROC *)&pThunk->u1.Function;
    if (*ppfn == pRealFunction) {
      printf("Function %s is not hooked.\n", lpFunctionName);
      return FALSE;
    }
    if ((void *)*ppfn == (void *)pRealFunction) {
      // The function pointer in the IAT matches the real function address.
      return FALSE;
    }
    pThunk++;
  }

  // If we reach here, the function's address in the IAT does not match the real
  // address.
  printf("Function %s is potentially hooked.\n", lpFunctionName);
  return TRUE;
}

BOOL HookIAT(const char *dllName, const char *funcName, void *hookFunc,
             void **originalFunc) {
  HMODULE hModule = GetModuleHandle(NULL); // Handle to the current module
  PIMAGE_IMPORT_DESCRIPTOR pImportDesc = GetImportDirectory(hModule);
  if (pImportDesc == NULL)
    return FALSE;

  // Iterate over import descriptors/DLLs.
  while (pImportDesc->Name) {
    char *importDllName = (char *)((PBYTE)hModule + pImportDesc->Name);
    if (_stricmp(importDllName, dllName) == 0) {
      // Found the DLL. Now find the function.
      PIMAGE_THUNK_DATA pThunk =
          (PIMAGE_THUNK_DATA)((PBYTE)hModule + pImportDesc->FirstThunk);
      PIMAGE_THUNK_DATA pOrigThunk =
          (PIMAGE_THUNK_DATA)((PBYTE)hModule + pImportDesc->OriginalFirstThunk);

      while (pOrigThunk->u1.Function) {
        PIMAGE_IMPORT_BY_NAME pImportByName =
            (PIMAGE_IMPORT_BY_NAME)((PBYTE)hModule +
                                    pOrigThunk->u1.AddressOfData);
        if (strcmp((char *)pImportByName->Name, funcName) == 0) {
          // Found the function. Perform the hook.
          DWORD oldProtect;
          if (VirtualProtect(&pThunk->u1.Function, sizeof(void *),
                             PAGE_EXECUTE_READWRITE, &oldProtect)) {
            *originalFunc =
                (void *)(pThunk->u1.Function);         // Save original address
            pThunk->u1.Function = (ULONG_PTR)hookFunc; // Set new function
            VirtualProtect(&pThunk->u1.Function, sizeof(void *), oldProtect,
                           &oldProtect);
            return TRUE;
          }
        }
        pThunk++;
        pOrigThunk++;
      }
    }
    pImportDesc++;
  }
  return FALSE;
}

BOOL UnhookIAT(const char *dllName, const char *funcName, void *originalFunc) {
  void *dummy;
  return HookIAT(dllName, funcName, originalFunc, &dummy);
}

fnMessageBoxA originalMessageBoxA =
    NULL; // To store the original MessageBoxA function.
// Hook handler for MessageBoxA
int WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption,
                         UINT uType) {
  printf("Hooked!: %s %s\n", lpText, lpCaption);
  return ((fnMessageBoxA)originalMessageBoxA)(hWnd, "Hooked!", lpCaption,
                                              uType);
}

void DummySleep() { return; }
int main() {
  /*
  BOOL isHooked = IsFunctionIATHooked("user32.dll", "MessageBoxA");
  printf("hooked: %d\n", isHooked);
  // Hook MessageBoxA
  if (HookIAT("user32.dll", "MessageBoxA", MyMessageBoxA,
              (void **)&originalMessageBoxA)) {
    MessageBoxA(NULL, "This is a test", "Hook Test", MB_OK);
    isHooked = IsFunctionIATHooked("user32.dll", "MessageBoxA");
    printf("hooked: %d\n", isHooked);

    // Unhook MessageBoxA
    printf("Unhooking function\n");
    UnhookIAT("user32.dll", "MessageBoxA", originalMessageBoxA);
    isHooked = IsFunctionIATHooked("user32.dll", "MessageBoxA");
    printf("hooked: %d\n", isHooked);
    MessageBoxA(NULL, "Hello world", "whats good", MB_OK);
  }
  */
  LPVOID originalFunc = NULL;
  HookIAT("kernel32.dll", "Sleep", DummySleep, (void **)&originalFunc);
  Sleep(0xfffff);
  printf("I am done!\n");
  return 0;
}
