#include "findk32.h"
// Define the structure for the InMemoryOrderModuleList
typedef struct _LDR_DATA_TABLE_ENTRY {
  LIST_ENTRY64 InMemoryOrderLinks;
  PVOID Reserved1[2];
  PVOID DllBase;
  PVOID Reserved2[2];
  UNICODE_STRING FullDllName;
  BYTE Reserved3[8];
  PVOID Reserved4[3];
  union {
    ULONG CheckSum;
    PVOID Reserved5;
  };
  ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

// Define the PEB_LDR_DATA structure
typedef struct _PEB_LDR_DATA {
  BYTE Reserved1[8];
  PVOID Reserved2[3];
  LIST_ENTRY64 InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

// Define the PEB structure
typedef struct _PEB {
  BYTE Reserved1[2];
  BYTE BeingDebugged;
  BYTE Reserved2[1];
  PVOID Reserved3[2];
  PPEB_LDR_DATA Ldr;
} PEB, *PPEB;

const wchar_t *alt_wcsstr(const wchar_t *haystack, const wchar_t *needle) {
  // If needle is empty, return the full string
  if (!*needle) {
    return haystack;
  }

  // Iterate over the haystack
  for (; *haystack != L'\0'; ++haystack) {
    // Check if the needle matches at this position in haystack
    const wchar_t *h = haystack;
    const wchar_t *n = needle;
    while (*n != L'\0' && *h == *n) {
      ++h;
      ++n;
    }
    // If the end of needle was reached, return the start of its occurrence in
    // haystack
    if (*n == L'\0') {
      return haystack;
    }
  }

  // If needle was not found, return NULL
  return NULL;
}

int strcmp(const char *s1, const char *s2) {
  while (*s1 && (*s1 == *s2)) {
    s1++;
    s2++;
  }
  return *(const unsigned char *)s1 - *(const unsigned char *)s2;
}

void *memset(void *s, int c, size_t n) {
  unsigned char *p = s;
  while (n--) {
    *p++ = (unsigned char)c;
  }
  return s;
}

// Function to retrieve the base address of kernel32.dll
PVOID GetKernel32BaseAddress() {
  // Retrieve the PEB address
  PEB *peb = (PEB *)__readgsqword(0x60);

  // Retrieve the InMemoryOrderModuleList
  LIST_ENTRY64 *moduleList = &peb->Ldr->InMemoryOrderModuleList;

  // Iterate over the module list
  for (LIST_ENTRY64 *entry = moduleList->Flink; entry != moduleList;
       entry = entry->Flink) {
    LDR_DATA_TABLE_ENTRY *module =
        CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

    // Compare the module name to find kernel32.dll
    WCHAR *name = module->FullDllName.Buffer;
    if (name != NULL) {
      // This is a very rudimentary check assuming 'kernel32' is part of the
      // module name A more robust implementation should convert the name to
      // lowercase and compare the entire string
      if (alt_wcsstr(name, L"KERNEL32") != NULL) {
        return module->DllBase;
      }
    }
  }

  return NULL; // kernel32.dll not found
}

// Function to find GetProcAddress given the base address of kernel32.dll
FARPROC FindGetProcAddress(HMODULE kernel32Base) {
  if (!kernel32Base)
    return NULL;

  // Cast the base address to IMAGE_DOS_HEADER*
  PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)kernel32Base;
  PIMAGE_NT_HEADERS ntHeaders =
      (PIMAGE_NT_HEADERS)((BYTE *)kernel32Base + dosHeader->e_lfanew);
  PIMAGE_EXPORT_DIRECTORY exportDirectory =
      (PIMAGE_EXPORT_DIRECTORY)((BYTE *)kernel32Base +
                                ntHeaders->OptionalHeader
                                    .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]
                                    .VirtualAddress);

  DWORD *addressOfFunctions =
      (DWORD *)((BYTE *)kernel32Base + exportDirectory->AddressOfFunctions);
  WORD *addressOfNameOrdinals =
      (WORD *)((BYTE *)kernel32Base + exportDirectory->AddressOfNameOrdinals);
  DWORD *addressOfNames =
      (DWORD *)((BYTE *)kernel32Base + exportDirectory->AddressOfNames);

  for (DWORD i = 0; i < exportDirectory->NumberOfNames; ++i) {
    if (strcmp("GetProcAddress",
               (const char *)kernel32Base + addressOfNames[i]) == 0) {
      return (FARPROC)((BYTE *)kernel32Base +
                       addressOfFunctions[addressOfNameOrdinals[i]]);
    }
  }

  return NULL;
}
