#include <windows.h>

#define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x20b

// Simplified structures for demonstration
typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWCHAR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY64 {
  LIST_ENTRY64 InMemoryOrderLinks;
  PVOID Reserved1[2];
  PVOID DllBase;
  PVOID EntryInProgress;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  // Other fields omitted for brevity
} LDR_DATA_TABLE_ENTRY64, *PLDR_DATA_TABLE_ENTRY64;

typedef struct _PEB_LDR_DATA64 {
  ULONG Length;
  BOOLEAN Initialized;
  HANDLE SsHandle;
  LIST_ENTRY64 InLoadOrderModuleList;
  LIST_ENTRY64 InMemoryOrderModuleList;
  LIST_ENTRY64 InInitializationOrderModuleList;
  PVOID EntryInProgress;
  BOOLEAN ShutdownInProgress;
  HANDLE ShutdownThreadId;
} PEB_LDR_DATA64, *PPEB_LDR_DATA64;

typedef struct _PEB64 {
  BOOLEAN InheritedAddressSpace;
  BOOLEAN ReadImageFileExecOptions;
  BOOLEAN BeingDebugged;
  BOOLEAN BitField;
  HANDLE Mutant;
  PVOID ImageBaseAddress;
  PPEB_LDR_DATA64 Ldr;
  // Other fields omitted for brevity
} PEB64, *PPEB64;

// Function prototypes
typedef HMODULE(WINAPI *pLoadLibraryA)(LPCSTR lpLibFileName);
typedef FARPROC(WINAPI *pGetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef BOOL(WINAPI *pCreateProcessA)(
    LPCSTR lpApplicationName, LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles,
    DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);

// Function to find a function in a module by name
void *FindFunction(const char *moduleName, const char *functionName) {
  // Access the PEB
  PEB64 *peb = (PEB64 *)__readgsqword(0x60);
  PPEB_LDR_DATA64 ldr = peb->Ldr;
  PLIST_ENTRY64 list = &ldr->InMemoryOrderModuleList;

  // Iterate through the loaded modules list
  for (PLIST_ENTRY64 entry = list->Flink; entry != list; entry = entry->Flink) {
    PLDR_DATA_TABLE_ENTRY64 moduleEntry =
        CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY64, InMemoryOrderLinks);
    UNICODE_STRING moduleNameUstr = moduleEntry->BaseDllName;

    // Convert UNICODE_STRING to char*
    char currentModuleName[260];
    int copySize = WideCharToMultiByte(
        CP_ACP, 0, moduleNameUstr.Buffer, moduleNameUstr.Length / sizeof(WCHAR),
        currentModuleName, sizeof(currentModuleName), NULL, NULL);
    currentModuleName[copySize] = '\0'; // Null-terminate the string

    // Compare module names
    if (_stricmp(currentModuleName, moduleName) == 0) {
      // Module found, parse its export table to find the function
      PVOID baseAddress = moduleEntry->DllBase;
      PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
      PIMAGE_NT_HEADERS64 ntHeaders =
          (PIMAGE_NT_HEADERS64)((PUCHAR)baseAddress + dosHeader->e_lfanew);

      // Ensure this is a valid PE file
      if (ntHeaders->Signature != IMAGE_NT_SIGNATURE ||
          ntHeaders->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        return NULL; // Not a valid PE file or not a 64-bit executable
      }

      // Locate the export directory
      PIMAGE_EXPORT_DIRECTORY exportDir =
          (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)baseAddress +
                                    ntHeaders->OptionalHeader
                                        .DataDirectory
                                            [IMAGE_DIRECTORY_ENTRY_EXPORT]
                                        .VirtualAddress);
      PDWORD names = (PDWORD)((PUCHAR)baseAddress + exportDir->AddressOfNames);
      PDWORD functions =
          (PDWORD)((PUCHAR)baseAddress + exportDir->AddressOfFunctions);
      PWORD ordinals =
          (PWORD)((PUCHAR)baseAddress + exportDir->AddressOfNameOrdinals);

      // Search for the function by name
      for (DWORD i = 0; i < exportDir->NumberOfNames; i++) {
        char *name = (char *)baseAddress + names[i];
        if (_stricmp(name, functionName) == 0) {
          // Function found
          DWORD functionRVA = functions[ordinals[i]];
          return (void *)((PUCHAR)baseAddress + functionRVA);
        }
      }
    }
  }

  return NULL; // Function not found
}

int main() {
  // Access the PEB for a 64-bit application
  PPEB64 peb = (PPEB64)__readgsqword(0x60);
  // Find LoadLibraryA and GetProcAddress
  pLoadLibraryA myLoadLibraryA =
      (pLoadLibraryA)FindFunction("kernel32.dll", "LoadLibraryA");
  pGetProcAddress myGetProcAddress =
      (pGetProcAddress)FindFunction("kernel32.dll", "GetProcAddress");

  // Use myLoadLibraryA and myGetProcAddress to find CreateProcessA
  HMODULE kernel32 = myLoadLibraryA("kernel32.dll");
  pCreateProcessA myCreateProcessA =
      (pCreateProcessA)myGetProcAddress(kernel32, "CreateProcessA");

  // Launch calc.exe
  STARTUPINFOA si;
  PROCESS_INFORMATION pi;
  ZeroMemory(&si, sizeof(si));
  si.cb = sizeof(si);
  ZeroMemory(&pi, sizeof(pi));

  myCreateProcessA(NULL, "calc.exe", NULL, NULL, FALSE, 0, NULL, NULL, &si,
                   &pi);
}
