#include "errhandlingapi.h"
#include "fileapi.h"
#include "handleapi.h"
#include "winnt.h"
#include <memoryapi.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

BYTE *LoadFileBytes(char *szFilePath, DWORD *lpDwSize) {
  printf("[*] Loading binary payload at path %s\n", szFilePath);
  HANDLE hFile = NULL;
  hFile = CreateFileA(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (hFile == INVALID_HANDLE_VALUE) {
    printf("Failed to open file %s because of %d\n", szFilePath,
           GetLastError());
    return NULL;
  }
  // we have a valid handle
  //
  *lpDwSize = GetFileSize(hFile, NULL);
  LPVOID lpFileBuffer =
      VirtualAlloc(NULL, *lpDwSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  if (lpFileBuffer == NULL) {
    printf("Could not get page of memory because of %d\n", GetLastError());
    CloseHandle(hFile);
    return NULL;
  }
  DWORD dwBytesRead = 0;
  if (!ReadFile(hFile, lpFileBuffer, *lpDwSize, &dwBytesRead, NULL)) {
    printf("Reading failed because of %d\n", GetLastError());
    CloseHandle(hFile);
    VirtualFree(lpFileBuffer, *lpDwSize, MEM_RELEASE);
    return NULL;
  }
  if (dwBytesRead != *lpDwSize) {

    printf("Reading failed because of %d\n", GetLastError());
    CloseHandle(hFile);
    VirtualFree(lpFileBuffer, *lpDwSize, MEM_RELEASE);
    return NULL;
  }

  // cleanup
  CloseHandle(hFile);
  return (BYTE *)lpFileBuffer;
}

typedef void EntryPoint(void);

void Run(LPVOID lpImageBase) {

  IMAGE_DOS_HEADER *lpImageDos = (IMAGE_DOS_HEADER *)lpImageBase;
  IMAGE_NT_HEADERS *lpNtHeader =
      (IMAGE_NT_HEADERS *)(lpImageBase + lpImageDos->e_lfanew);
  IMAGE_OPTIONAL_HEADER opHeader = lpNtHeader->OptionalHeader;
  LPVOID lpEntry = (lpImageBase + opHeader.AddressOfEntryPoint);
  ((EntryPoint *)lpEntry)();
}

BYTE *MemoryMapPE(BYTE *lpFileBytes, DWORD dwSize) {
  IMAGE_DOS_HEADER *lpImageDos = (IMAGE_DOS_HEADER *)lpFileBytes;
  IMAGE_NT_HEADERS *lpNtHeader =
      (IMAGE_NT_HEADERS *)(lpFileBytes + lpImageDos->e_lfanew);
  IMAGE_OPTIONAL_HEADER opHeader = lpNtHeader->OptionalHeader;
  DWORD dwSizeOfImage = opHeader.SizeOfImage;

  BYTE *lpImageBase = VirtualAlloc(
      NULL, dwSizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
  // TODO ommit error checking

  // Copy the headers
  memcpy(lpImageBase, lpFileBytes, opHeader.SizeOfHeaders);
  IMAGE_SECTION_HEADER *sections = IMAGE_FIRST_SECTION(lpNtHeader);
  DWORD dwNumSections = lpNtHeader->FileHeader.NumberOfSections;
  for (DWORD i = 0; i < dwNumSections; i++) {
    LPVOID dest = (LPVOID)(lpImageBase + sections[i].VirtualAddress);
    LPVOID src = (LPVOID)(lpFileBytes + sections[i].PointerToRawData);
    // TODO: handle situation where virtual size/physical size is 0
    //
    if (sections[i].SizeOfRawData != 0) {
      memcpy(dest, src, sections[i].SizeOfRawData);
    }
  }
  return lpImageBase;
}

int main(int argc, char **argv) {
  if (argc != 2) {
    printf("Usage: %s path_to_exe\n", argv[0]);
    return 1;
  }
  DWORD dwFileSize = 0;
  BYTE *lpFileBytes = LoadFileBytes(argv[1], &dwFileSize);
  if (lpFileBytes == NULL) {
    printf("Failed to load file. Goodbyte!\n");
    return 1;
  }

  LPVOID lpImageBase = MemoryMapPE(lpFileBytes, dwFileSize);
  // Free FileBytes
  Run(lpImageBase);
}
