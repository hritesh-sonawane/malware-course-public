#include <psapi.h>
#include <stdio.h>
#include <windows.h>

int main(int argc, char *argv[]) {
  if (argc != 2) {
    printf("Usage: ./%s <pid>\n", argv[0]);
    return 0;
  }
  int pid = atoi(argv[1]);
  HANDLE hProcess = NULL;
  if (pid == 0) {
    hProcess = GetCurrentProcess();
    pid = GetProcessId(hProcess);
    printf("Current PID=%d\n", pid);
  } else {
    hProcess = OpenProcess(
        PROCESS_QUERY_INFORMATION |
            PROCESS_VM_READ, // If we want to Query basic information, we need
                             // these access rights
        FALSE, // We don't need child processes to inherit this handle
        pid    // Processes Identifier (PID)
    );
  }
  if (!hProcess) {
    printf("Failed to open Processes %d because of %d\n", pid, GetLastError());
    printf("WHat?\n");
    return 0;
  }
  HMODULE hMods[1024];
  DWORD cbNeeded;
  // todo: make assignment to call EnumProcessModuels twice!
  char procNameBuff[MAX_PATH];
  DWORD size = sizeof(procNameBuff);
  BOOL bRes = QueryFullProcessImageNameA(hProcess, 0, procNameBuff, &size);
  if (bRes) {
    printf("[+] Executable Path: %s\n", procNameBuff);
  }

  if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {
    for (int i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
      char szModName[MAX_PATH];
      // Get the path to the module on disk!
      if (GetModuleFileNameExA(hProcess, hMods[i], szModName,
                               sizeof(szModName) / sizeof(char))) {
        // Print the module name, and the base address in the remote processes
        printf("\t%s  0x%p \n", szModName, (void *)hMods[i]);
      }
    }
  }

  if (hProcess) {
    printf("Closed Handle to %d\n", pid);
    CloseHandle(hProcess);
  }
  return 0;
}
