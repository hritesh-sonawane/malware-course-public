#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include "debug.h"

// Helper: print the intended usage
void printUsage(char** argv){
    printf("Useage: ./%s e|d data\ne for encode\nd for decode", argv[0]);
    exit(-1);
}

// Helper: Get the lenght of a string, truncating up to  ~4GB
// Technically, this is overkill for our cmdline function. Think about why :-)
// This will be useful though, when you start working with larger files. 
#define dwstrnlen(_Str) (DWORD) strnlen(_Str, 0xffffffff)


// base64Encode: Caller is responsible for freeing buffer
BOOL base64EncodeA(BYTE* message, DWORD dwMessage, LPSTR* lpBuffer, DWORD* dwBuffer ){
    BOOL bResult = FALSE;
    // your solution here!
}


// base64Decode: Caller is responsible for Freeing fuffer
BOOL base64DencodeA(LPSTR lpStr, DWORD dwStr, BYTE** lpBuffer, DWORD* dwBuffer){
    BOOL bResult = FALSE;
    // your solution here!
}



int main(int argc, char** argv){
    DEBUG_PRINTF("Starting execution of %s\n", __FILE__);

    if(argc !=3 ){
        printUsage(argv);
    }
    // untyped pointer for either encoding or decoding
    void *lpVoid = NULL; 

    // Size of the argument. Note that Base64 works with BYTEs but 
    // since we are passing args via the command line, we can't have null bytes.
    // So, strlen works here
    DWORD dwArgLen = 0;
    // Size of returned type 
    DWORD dwSize = 0;
    
    BOOL bResult = FALSE;
    // Check if we are encoding or decoding
    if (strlen(argv[1]) != 1){
        printUsage(argv);
    }
    switch (argv[1][0]){
        case 'e':
            // encode data to string 
            dwArgLen =  dwstrnlen(argv[2]);
            bResult = base64EncodeA( (BYTE*) argv[2],dwArgLen,  (LPSTR*) &lpVoid, &dwSize );
            DEBUG_PRINTF("base64EncodeA: %d\n",bResult);

            if (bResult){
                printf("Result:%s\n", (LPSTR) lpVoid);

                DEBUG_HEX( lpVoid, dwSize );
                // Don't forget!
                free(lpVoid);
            } else{
                
                DEBUG_PRINTF("base64EncodeA Failed\n");
            }
            break;
        case 'd':
            dwArgLen =  dwstrnlen(argv[2]);
            bResult = base64DencodeA(argv[2],dwArgLen, (BYTE**) &lpVoid, &dwSize );
            if (bResult){
                // Note this is unsafe if we actually allow arbitrary values 
                printf("%s\n", (LPSTR) lpVoid);
                DEBUG_HEX( lpVoid, dwSize );

                // Don't forget!
                free(lpVoid);
            } 
            break;
        default:
            printUsage(argv);
    }
    return 0;
}